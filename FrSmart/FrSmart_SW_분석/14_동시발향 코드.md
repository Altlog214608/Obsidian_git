좋습니다 👍 올려주신 **FrSmart.py**와 **dsComm.py**를 기준으로 “동시발향” 기능을 정리해드릴게요.  
핵심은 **여러 향수 밸브를 동시에 열어서 원하는 비율(duty percent)로 분사**하는 과정입니다.

---

# 🔹 동시발향( Simultaneous Scent Control ) 총정리

## 1. 개념

- 장치에는 여러 개의 **밸브(최대 12개)**가 있고, 각각이 하나의 향수 슬롯을 담당.
    
- 일반 발향은 **특정 번호 하나만 선택**해서 분사.
    
- **동시발향**은 여러 밸브를 동시에 일정 비율(듀티 값)로 열어 **믹스된 향**을 발생시킴.
    

---

## 2. 주요 함수 흐름

### (1) `pb_mix_test()`

- 사용자가 믹싱 페이지에서 “테스트 버튼”을 누를 때 호출.
    
- 슬라이더에서 설정한 값들을 읽어와 `scent_config` 딕셔너리 구성:
    

```python
scent_config = { 1: 40, 3: 60 }   # 예: 1번 향수 40%, 3번 향수 60%
```

- 이 `scent_config`를 `progressBarMixScentAndClean()`에 전달.
    

---

### (2) `progressBarMixScentAndClean(scent_config, progress_bar)`

- 프로그레스바를 돌리면서 실제 발향 명령 전송.
    
- 내부에서 **`requestSimultaneousScentControl(scent_config)`** 호출 → 동시발향 핵심 실행.
    

---

### (3) `requestSimultaneousScentControl(scent_config)`

1. **펌프 파워 설정 전송**
    
    ```python
    sendMsg_power = dsComm.sendMsgForPumpPower_C(id=1, run_power, clean_power)
    ```
    
    → 발향펌프와 세정펌프 출력 세기 설정.
    
2. **펌프 시간 설정 전송**
    
    ```python
    sendMsg_time = dsComm.sendMsgForPumpTime_C(id=1, run_time, clean_time)
    ```
    
    → 발향 지속 시간과 세정 시간 지정.
    
3. **밸브 듀티 설정 (여러 개 동시에)**
    
    - `scent_config`를 순회하면서 각 향수 번호에 해당하는 보드/포트 위치 계산.
        
    - 보드 단위로 duty 배열 생성 후,
        
        ```python
        sendMsg_valve = dsComm.sendMsgForValveDuty_C(id=1, board_index, valve_duties)
        ```
        
        호출하여 보드별 밸브 개방 비율 설정.
        
4. **명령 실행 (Run & Clean)**
    
    ```python
    sendMsg_cmd = dsComm.sendMsgForCommand_C(id=1, command=4)  # CMD_RUNCL = 4
    ```
    
    → “발향 + 세정”을 동시에 실행하는 최종 명령.
    

---

## 3. 하위 메시지 생성 (dsComm.py)

- `sendMsgForPumpPower_C()` → 펌프 출력 세기 패킷 생성.
    
- `sendMsgForPumpTime_C()` → 발향/세정 시간 패킷 생성.
    
- `sendMsgForValveDuty_C()`
    
    - 각 밸브의 duty 값을 **5차식 보정 계산** 후 장치 제어 값으로 변환.
        
    - duty=0이면 닫고, >0이면 지정 비율만큼 개방.
        
- `sendMsgForCommand_C()` → 최종 실행 명령 패킷 생성.
    

모든 메시지는 **Modbus CRC16**으로 검증 후 시리얼로 전송됨.

---

## 4. 동작 순서 요약 (쉽게)

1. UI 슬라이더에서 비율 설정 (예: 1번 40%, 3번 60%).
    
2. `pb_mix_test()` → `progressBarMixScentAndClean()` → `requestSimultaneousScentControl()`.
    
3. 내부에서 차례로:
    
    - 펌프 세기 설정
        
    - 펌프 시간 설정
        
    - 밸브별 듀티 설정 (동시에 여러 개 열림)
        
    - 실행 명령 전송
        
4. 지정된 시간 동안 여러 향수가 동시에 분사.
    
5. 끝나면 세정 과정 실행.
    

---

✅ 이렇게 정리하면, “동시발향”은 **UI → 슬라이더 값 수집 → 프로토콜 메시지 조립 → 펌프+밸브 제어 → 실행 명령**의 흐름으로 작동합니다.

---

좋아요! 동시발향에서 실제로 **시리얼로 나가는 패킷(hex)**을, 구성/의미/예시까지 한 번에 보기 좋게 정리했습니다. (아래 주소·명령 값은 코드 그대로 인용했어요: `MFC_CMD=0x1068`, `MFC_RPW=0x106A`, `MFC_POT=0x106C`, `MFC_COT=0x106E`, 밸브 듀티 시작 주소 `0x1086`, Write Single=6, Write Multiple=16)

---

# 패킷 기본 형태(요약)

- **Write Single Register (기능코드 0x06)**  
    `[ID][06][ADDR_H][ADDR_L][VAL_H][VAL_L][CRC_L][CRC_H]`  
    (CRC는 Modbus-RTU, little-endian)
    
- **Write Multiple Registers (기능코드 0x10)**  
    `[ID][10][ADDR_H][ADDR_L][COUNT_H][COUNT_L][BYTE_CNT][DATA...][CRC_L][CRC_H]`  
    (DATA는 2바이트 단위 레지스터들의 연속)
    

---

# 1) 펌프 파워 설정 (Run Pump Power)

- 목적: 발향 펌프 출력 세기 설정
    
- 주소/기능: `0x106A`, 기능 6(Write Single)
    
- 예시: **ID=1, run_power=300(0x012C)**
    
- **패킷(hex)**: `01 06 10 6A 01 2C AD 5B`
    
    - 01=ID, 06=기능, 10 6A=주소, 01 2C=값, AD 5B=CRC(LE)
        

---

# 2) 발향 시간 설정 (Run Time)

- 목적: 발향 지속 시간(단위는 FW 기준)을 장치에 전달
    
- 주소/기능: `0x106C`, 기능 6
    
- 예시: **run_time=2000(0x07D0)**
    
- **패킷(hex)**: `01 06 10 6C 07 D0 4E BB`
    

---

# 3) 세정 시간 설정 (Clean Time)

- 목적: 세정(클린) 시간 설정
    
- 주소/기능: `0x106E`, 기능 6
    
- 예시: **clean_time=1500(0x05DC)**
    
- **패킷(hex)**: `01 06 10 6E 05 DC EE 1E`
    

---

# 4) 밸브 듀티 일괄 설정 (보드 단위, 6포트 동시)

- 목적: **동시발향의 핵심**. 한 보드(6개 포트)의 듀티(%)를 한 번에 씀
    
- 시작 주소: `0x1086 + (board_index * 8)`, 기능 16(Write Multiple)  
    → 첫 번째 보드(`board_index=0`)는 `0x1086`부터 6레지스터 기록.
    
- 내부 로직: 듀티(%)를 그대로 쓰지 않고 **5차식 보정**(fscale/offset/coeff/zduty) 후 0~100% 범위로 변환하여 **정밀 듀티(sduty)** 생성 뒤 전송합니다. (코드 그대로)
    

### 예시 시나리오

- **동시발향 구성**: 1번 40%, 3번 60% (나머지 0%) → 첫 보드 6포트 배열로 표현하면 `[40, 0, 60, 0, 0, 0]`
    
- 코드 보정 결과(5차식 적용 후 0~100%로 클램프):
    
    - 포트0(1번): **48.28% → 4828(0x12DC)**
        
    - 포트2(3번): **51.72% → 5172(0x1434)**
        
    - 나머지: 0 → `0x0000`  
        (보정식/제로오프셋/클램프는 코드와 동일)
        
- 쓰는 레지스터 개수: 6개 → 바이트수 12
    
- **패킷(hex)**:  
    `01 10 10 86 00 06 0C 12 DC 00 00 14 34 00 00 00 00 00 00 3E 17`
    
    - 01=ID
        
    - 10=기능(Write Multiple)
        
    - 10 86=시작주소
        
    - 00 06=레지스터 수(6)
        
    - 0C=바이트수(12)
        
    - **12 DC**(포트0), **00 00**(포트1), **14 34**(포트2), **00 00**(포트3), **00 00**(포트4), **00 00**(포트5)
        
    - **3E 17**=CRC(LE)  
        (이 보드-단위 쓰기는 `sendMsgForValveDuty_C()`에서 구성합니다.)
        

> 참고: UI에서 `{scent_no: duty_percent}` 맵을 보드/포트로 묶은 뒤 보드별로 위 패턴을 여러 번 보내는 흐름이 **동시발향**의 실제 구현입니다.

---

# 5) 실행 명령 (Run / Clean / Stop / Run&Clean)

- 주소/기능: `0x1068`, 기능 6
    
- 명령 코드: `1=run, 2=clean, 3=stop, 4=run&clean`
    
- 예시: **Run&Clean(4)**
    
- **패킷(hex)**: `01 06 10 68 00 04 0D 15`  
    (실제 동시발향 루틴에서도 마지막에 이 명령을 전송합니다.)
    

---

## 전체 흐름(예시 한 번에 보기)

1. 펌프 파워 → `01 06 10 6A 01 2C AD 5B`
    
2. 발향 시간 → `01 06 10 6C 07 D0 4E BB`
    
3. 세정 시간 → `01 06 10 6E 05 DC EE 1E`
    
4. 밸브 듀티(보드0) → `01 10 10 86 00 06 0C 12 DC 00 00 14 34 00 00 00 00 00 00 3E 17`
    
5. 실행 명령 Run&Clean → `01 06 10 68 00 04 0D 15`
    

이 순서를 **보드 수만큼(동시에 쓰는 보드 모두)** 수행하고 마지막에 실행 명령을 주면, 설정된 듀티/시간/파워대로 **여러 향이 동시에 분사**됩니다. (구현 라우팅은 `requestSimultaneousScentControl()` 및 `requestMultiScentEmit_C()` 참고)

---

## 추가 팁

- CRC는 **Modbus-RTU little-endian**으로 끝 2바이트가 붙습니다(위 예시 모두 적용).
    
- 듀티 보정식 때문에 **UI에서 40%/60%**로 설정해도 내부 전송 값은 **대략 48.28%/51.72%**처럼 보정됩니다(하드웨어 특성/캘리브레이션 반영).
    
