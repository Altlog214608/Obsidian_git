좋아, 지금 “동시 발향(혼합)”을 **FrSmart ↔ 펌웨어**로 붙여서 테스트하려면 이렇게 가면 됩니다. 핵심은 FrSmart가 지금 쓰는 **단일 병 명령(NF, 0x1068~)** 대신, **MFC 혼합 경로**를 써서 각 라인(밸브)의 듀티를 한 번에 내려보내고 `RUN`을 트리거하는 거예요.

# 어디까지 펌웨어가 준비돼 있나 (근거)

- 펌웨어에는 이미 **혼합(멀티플로우)용** API가 있어요.
    
    1. `SetDutyBoard_MFC()`가 **솔레노이드 보드 1장(6라인)의 듀티 6개**를 한 방에 `0x10(Write Multiple Registers)`로 씁니다. 이때 **fscale·offset·coeff·dutyzero**를 이용해 실제 보드가 먹는 듀티값으로 보정합니다.
        
    2. `C_RunProcess()`는 (필요 시) **펌프 파워/시간/밸브 PWM 주파수**를 `WriteSingleReg_MFC`로 세팅하고, **보드 수만큼 `SetDutyBoard_MFC()` 호출** 후 **`MFC_CMD`에 RUN**을 씁니다.
        
- **보정 파라미터(fscale, offset, coeff[], dutyzero[])**는 `ConfigProVal.cfg`에서 읽어 `s_mfc`에 로드합니다. (당신이 말한 fsscale 2.5, offset 41과 매칭)
    
- 주소 맵: 혼합 듀티 베이스 주소는 **`MFC_SPA (0x1086)`**. 포트 x의 실제 주소는 **보드번호와 포트 인덱스로 계산**합니다(주석의 계산식 참고).
    

> 한줄 결론: **FrSmart가 각 라인의 “목표 %”를 보내면, 펌웨어가 보정식으로 실제 듀티를 만들어 6개씩 써 넣고 RUN** 합니다.

---

# FrSmart에서 무엇을 바꿔야 하나 (방향)

현재 FrSmart는 `sendMsgForEmitClean(주소 4200, qor=8)`로 **NF 단일 향**을 쏘고 있어요. 혼합 테스트를 하려면 **MFC 경로로 아래 순서**를 보내면 됩니다.

### A. 초기 질의(1회)

1. **보드 개수 읽기**: `ReadRegister` (func=0x04 or 0x03) @ `MFC_NSB(0x0FBD)` → 보드 장수(=최대 13), 총 라인 수(=보드×6) 파악.
    
2. (선택) 현재 라인 상태/듀티 읽기: `MFC_SPS`/`MFC_SPA`로 모니터링.
    

### B. 혼합 명령(테스트마다)

1. **펌프 조건 설정(필요 시 변경된 것만)**
    
    - Run Power: `WriteSingleReg` @ `MFC_RPW(0x106A)`
        
    - Run Time(sec): `WriteSingleReg` @ `MFC_POT(0x106C)`
        
    - Valve PWM Freq(kHz): `WriteSingleReg` @ `MFC_VPF(0x1075)`  
        (펌웨어의 `C_RunProcess()`가 실제 이렇게 보냄)
        
2. **보드별 듀티 내려쓰기**
    
    - 보드 i(0‑based)에 대해 `SetDutyBoard_MFC(i)` 동작과 동일하게, **`MFC_SPA + (i*8)`부터 6레지스터**를 `0x10(Write Multiple)`로 씁니다. 데이터는 **각 라인 듀티의 16비트 값**(단위 = %×100). 펌웨어는 내부에서 보정하지만, **그대로 0~10000(=100.00%) 값**을 내려도 문제없습니다.
        
3. **Run 트리거**: `WriteSingleReg` @ `MFC_CMD(0x1068)` ← `CMD_RUN(1)`
    

> 이렇게 하면 “3번향 50%, 5번향 50%”처럼 **여러 라인에 동시에 듀티를 분배**해서 한 번에 분사됩니다. 총합은 100%로 맞추는 걸 권장(보정 로직과 펌프 용량 감안).

---

# “3번, 5번 50%·50% → 1.25·1.25” 매핑은 어디서 보정되나

- 보정 흐름은 펌웨어의 `SetDutyBoard_MFC()` 안에 들어 있습니다.
    
    - UI에서 넣은 duty% → `xvalue = duty%/100 × fscale/100` → **다항식(coeff[0..5])** 적용 → `dutyzero`/`offset` 보정 → **0~100% clamp** → **sduty(정수, %×100)**로 변환 후 보드에 씁니다. (코멘트에 “fscale full scale, offset, coeff, dutyzero” 읽는 부분과 계산식 확인)
        
- 즉 **FrSmart는 “원하는 비율(%)”만 보내고**, 실제 유량계 기준의 흐름(예: 1.25 LPM 근접)은 **펌웨어 보정**으로 맞춥니다. fscale=2.5, offset=41이 그 역할.
    

---

# 바로 써먹는 최소 구현(FrSmart에 추가)

아래는 **보드 1장(6라인)만 있는 경우** 예시입니다. (여러 보드면 for‑loop로 반복)

```python
def mfc_write_single(self, addr, value):  # func=0x06
    pkt = dsComm.sendMsgWriteSingle(id=1, func=6, address=addr, value=value)
    self.write_data(pkt)

def mfc_write_6duties_board0(self, d0,d1,d2,d3,d4,d5):  # func=0x10
    # dX는 0~10000(=100.00%) 정수. 예: 50% -> 5000
    start_addr = 0x1086  # MFC_SPA, board0
    regs = [d0,d1,d2,d3,d4,d5]
    pkt = dsComm.sendMsgWriteMultiple(id=1, func=16, address=start_addr,
                                      reg_count=6, values=regs)  # 6*2 bytes
    self.write_data(pkt)

def mfc_run(self, run_power_percent, run_time_sec, valve_khz):
    self.mfc_write_single(0x106A, run_power_percent)  # MFC_RPW
    self.mfc_write_single(0x106C, run_time_sec)       # MFC_POT
    self.mfc_write_single(0x1075, valve_khz)          # MFC_VPF
    self.mfc_write_single(0x1068, 1)                  # MFC_CMD = CMD_RUN
```

“3번향 50%, 5번향 50%”를 **board0의 port3/port5**로 가정하면:

```python
# 라인 인덱스(예시): [p1,p2,p3,p4,p5,p6]
duties = [0, 0, 5000, 0, 5000, 0]  # 50% = 5000
self.mfc_write_6duties_board0(*duties)
self.mfc_run(run_power_percent=50, run_time_sec=3, valve_khz=1)
```

> 실제 포트 ↔ 향 병 번호 매핑만 정확히 맞추면 됩니다. 필요 시 `MFC_SPA` 주석의 **주소 계산식**으로 보드/포트를 산출하거나, 기존 UI의 포트 매핑 테이블을 그대로 쓰세요.

---

# 테스트 루틴(권장)

1. **연결·기초 확인**
    
    - `MFC_NSB(0x0FBD)` 읽기 → 보드 수 체크, `MFC_CGP`(압력) 폴링으로 통신 OK 확인.
        
2. **정지 상태에서 듀티만 내려보기**
    
    - `SetDutyBoard_MFC`에 해당하는 0x10 프레임만 보내고, 바로 `MFC_SPA`를 읽어 내려간 값이 저장됐는지 확인.
        
3. **RUN 트리거 후 유량계 검증**
    
    - `MFC_CMD=RUN` → 유량계 실제 값이 목표(예: 1.25/1.25)에 근접하는지 확인.
        
    - 다르면 **ConfigProVal.cfg**의 coeff/offset/dutyzero를 미세 조정(펌웨어와 동일 파일을 장치가 읽는 구조라면 그쪽 조정).
        

---

# UI/코드 구성 팁

- FrSmart에 **“혼합 모드” 토글**을 추가해서
    
    - OFF: 기존 NF 단일 향(4200/8 regs)
        
    - ON: MFC 혼합(보드별 듀티 + RUN)
        
- 혼합 UI는 **라인별 퍼센트 입력**(합 100 강조)만 받게 단순화. 펌프 파워/시간/밸브 주파수는 상단 공통 영역에서 입력.
    
- 안전장치: 합이 100이 아니면 RUN 버튼 비활성, 듀티 0~100% 범위 체크.
    

---

원하면 제가 **FrSmart.py에 바로 붙여 넣는 함수들(dsComm 호출 포함)**과, **보드가 2장 이상일 때의 라인→주소 매핑 유틸**까지 작성해서 드릴게요.  
또, 지금 사용하는 `ConfigProVal.cfg`의 **fscale=2.5, offset=41** 전제로, “두 라인 50/50 → 1.25/1.25”가 유지되도록 **간이 보정 시뮬레이터**도 덧붙여 드릴 수 있어요.