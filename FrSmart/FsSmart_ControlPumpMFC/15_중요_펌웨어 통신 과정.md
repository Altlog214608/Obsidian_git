

---

## 1. 구조체와 데이터 흐름

- `s_scent` 같은 구조체에 명령과 제어값을 채워 넣고,
    
- 그 데이터를 `s_serial` 구조체의 `send[]` 배열에 **`index++`** 방식으로 바이트 단위로 차례차례 넣습니다.
    
- `s_serial` 구조체는 시리얼 통신을 하는 데 필요한 송수신 버퍼(`send[]`, `read[]`), 포트 설정, 상태 플래그 등을 모두 포함하는 중요한 데이터 구조입니다.
    

---

## 2. `SendToCom` 함수 역할과 동작

`SendToCom` 함수는 다음 단계를 수행합니다:

1. **CRC 부착**
    
    - `scom->crc` 값에 따라 CRC 검사를 위한 체크섬을 `send[]` 배열 뒤에 붙입니다.
        
    - `case 1`: `AttachCRC16` - 일반 CRC16 함수
        
    - `case 2`: `AttachModbusCRC` - MODBUS CRC16 체크섬 함수
        
    - CRC 값을 넣은 만큼 `sendbyte`(전송 바이트 수)를 2바이트 증가시킵니다.
        
2. **프로토콜 포맷팅**
    
    - `scom->protocol`에 따라 송신 데이터 포맷을 조절합니다.
        
    - `0`: 기본 문자열 종결자(terminator) 추가 → `sprintf`로 `send[]` 뒤에 terminator 문자(예: `\n` 또는 `\r`)를 붙임
        
    - `1`: SLIP 프로토콜 인코딩 → `EncodeSLIP()` 함수 호출
        
    - `2`: MODBUS 프로토콜은 별도 처리 없음 (CRC 첨부 후 그대로 송신)
        
3. **디버그 출력**
    
    - `scom->debug` 플래그에 따라 `send[]` 내용(16진수 또는 문자열)을 콘솔에 출력해 디버깅 지원
        
4. **실제 전송: `ComWrt` 호출**
    
    - 최종적으로 `send[]` 버퍼와 `sendbyte` 길이, 포트 번호(`scom->port`)를 인자로 `ComWrt()` 함수 호출하여 데이터를 시리얼 포트로 전송함
        
    - `ComWrt`는 시리얼 포트에 바이트 스트림을 쓰는 운영체제 레벨 혹은 드라이버 레벨 함수로 추정됨
        
    - 전송 후, `ReturnRS232Err()`로 하드웨어/통신 오류 여부를 확인하여 `scom->error`에 저장
        
5. **입력 큐 정리**
    
    - `FlushInQ(scom->port)` 함수로 해당 포트의 입출력 버퍼를 정리하는 것으로 보임(잘못된 잔류 데이터 제거 등)
        
6. **에러 처리 및 반환**
    
    - 오류가 있으면 `-1` 반환, 정상시 `0` 반환
        

---

## 3. 역할 정리

|단계|내용|
|---|---|
|CRC 처리|프로토콜에 맞는 체크섬을 송신 데이터에 붙임|
|프로토콜 변환|간단한 문자열 종료 문자 붙이기 또는 SLIP 인코딩 등|
|디버그|송신 데이터 출력(필요 시)|
|데이터 전송|`ComWrt` 호출하여 `send[]` 데이터를 시리얼 포트로 전달|
|후처리 및 상태 확인|통신 에러 검사 및 입출력 버퍼 초기화|
|반환|성공/실패 상태 반환|

---

## 4. 결론

- `SendToCom` 함수는 `s_serial` 구조체가 가지고 있는 송신 버퍼를 완성된 패킷 형태로,
    
- CRC 처리와 프로토콜 변환까지 한 뒤,
    
- `ComWrt` (시리얼 포트 쓰기 함수)에 보내 실제 하드웨어 통신(시리얼 송신)을 수행시킵니다.
    
- 전송 완료 후 버퍼 정리를 위해 `FlushInQ`를 호출하고, 오류 발생 시 적절한 예외 처리를 합니다.
    

즉,  
**`SendToCom`은 명령 패킷을 최종적으로 시리얼 포트로 내보내는 “송신 관문(gateway)” 역할**이라 보시면 됩니다.

---

필요하시면 `ComWrt` 함수의 구체적인 구현이나 시리얼 통신 드라이버 레벨의 동작, 그리고 `FlushInQ` 함수 역할도 추가 설명 가능합니다. 언제든 요청해 주세요.

1. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/10180242-d96f-4d67-b2fd-f209897a8324/ControlPumpNF.c](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/10180242-d96f-4d67-b2fd-f209897a8324/ControlPumpNF.c)
2. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/5c219ade-978f-408e-be3b-27e55d4c766e/ControlPumpNF.h](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/5c219ade-978f-408e-be3b-27e55d4c766e/ControlPumpNF.h)