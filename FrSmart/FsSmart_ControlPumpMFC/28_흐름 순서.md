좋아, 코드 기준으로 흐름을 정확히 정리해줄게. 핵심은 “언제 s_mfc가 채워지는가, dutyzero가 뭔가, duty/status의 *가 뭔가, 그리고 PC→펌웨어로 값이 어떻게 흘러가는가”야.

# s_mfc가 채워지는 순간 (초기화 순서)

1. 프로그램 시작 → 통신 설정 후 펌웨어에 보드 개수 질의
    

- `InitProcess()`가 시리얼 열고 `InitProcess_MFC()` 호출 → 여기서 먼저 **솔레노이드 보드 수(MFC_NSB)** 를 읽고, 그 응답을 `DecodeData_MFC()`로 디코딩해.
    
- `DecodeData_MFC()`에서 **보드 수를 보고 동적 메모리 할당**을 해:
    
    - `s_mfc.duty` (각 포트 전송값 저장), `s_mfc.status`, `s_mfc.lhindex`, **`s_mfc.dutyzero`(= zduty 표)** 를 malloc으로 잡아둠.
        

2. UI 쪽 기본 구성 + 보정 파라미터(곡선/zduty) 로드
    

- 보드 수가 확보되면 `InitConfig_MFC()`가 불리고, 이어서 **`ReadConfigProVal_MFC()`** 가 실행돼.
    
- 여기서 **`fscale`**, **`offset`**, **`coeff[0..5]`**, 그리고 **각 보드의 `zduty`(= dutyzero 배열)** 을 `ConfigProVal.cfg`에서 읽어 **`s_mfc`에 그대로 채워**.
    
    - 특히 `Scan(... "zduty = %6f[x]" ...)` 로 읽어서 `s_mfc.dutyzero[i + j*6]`에 저장하는 부분이 바로 **zduty 표를 s_mfc로 옮기는 곳**.
        

요약:

- **메모리 할당**은 MFC_NSB 읽은 뒤 `DecodeData_MFC()`에서,
    
- **보정 파라미터와 zduty 표 채우기**는 `ReadConfigProVal_MFC()`에서 이뤄진다.
    

# dutyzero(= zduty) 가 의미하는 것

- `dutyzero`는 **“각 채널의 무유량(Zero Flow) 절대 듀티”** 표야. 즉 장비마다 달라지는 **채널별 오프셋**. `ConfigProVal.cfg`에서 읽어와 `s_mfc.dutyzero[...]`에 저장한다.
    
- 그래서 “기본값이 0이냐?”가 아니라, **파일에 적힌 zduty 실수값들(예: 38.0, 41.0 …)** 이 그대로 들어간다.
    

# duty/status 앞의 * 는 뭐야?

- `unsigned short *duty;`, `unsigned short *status;` 의 **`*`는 포인터**라는 뜻.
    
    - 즉 **동적 배열**로 쓰려고 보드 수를 읽은 다음에 `malloc`으로 크기를 정해 **런타임에 메모리를 잡는 구조**야. 이 할당은 위에서 말한 `DecodeData_MFC()`의 MFC_NSB 케이스에서 이루어짐.
        

# PC → 펌웨어로 값이 채워져 전송되는 경로

1. **UI에서 %를 입력**하면 내부적으로 `s_mfc.duty[]`에 “요청값(보통 %×100 형태)”이 들어가거나, 혹은 장비에서 읽어온 값을 `DecodeData_MFC(MFC_SPA)`에서 `s_mfc.duty[]`로 채워둘 수 있어. (SPA 응답을 배열로 흡수)
    
2. **실행(RUN) 버튼** → `C_RunProcess()` 안에서 먼저 펌프 파라미터(파워, 시간, 주파수) 필요 시 단일 레지스터로 쓰고, **각 보드에 대해 `SetDutyBoard_MFC(i)`** 를 호출해 **6채널 듀티 묶음(0x10 Write Multiple Registers)** 을 보낸 뒤, 마지막에 **`MFC_CMD`에 RUN(0x1068)** 을 씀.
    
3. `SetDutyBoard_MFC()` 내부 로직(가장 중요)
    

- `sad`(Select Absolute Duty) 옵션이 꺼져 있고, 해당 채널 `s_mfc.duty[...]`가 0이 아니면 **“%입력 → 보정식 → 절대듀티 → x100 → 2바이트”** 순서로 바꿔 담아 전송한다.
    
    - 변환식은 코드 그대로:
        
        - `xvalue = (s_mfc.duty[dindex+i] / 100.0) * s_mfc.fscale / 100.0;` ← **주의: %값을 100으로 나누고 다시 100으로 나누는 이중 스케일이 있음**
            
        - `fduty = Σ_{j=0..5} coeff[j] * pow(xvalue, j);`
            
        - `fduty += (dutyzero - offset);` 후 `+0.005` 라운딩 보정, **하한/상한 클램프** (≤dutyzero → 0.0, >100 → 100).
            
        - `sduty = (unsigned short)(fduty * 100);` 를 **빅엔디안 두 바이트로** payload에 적재.
            
- 반대로 **`sad`가 켜졌거나 해당 채널 duty가 0이면**, 보정 없이 **`s_mfc.duty[...]` 값 자체**를 두 바이트로 싣는다(절대모드).
    

4. 완성된 프레임은 `SendToCom()` 에서 **MODBUS CRC** 가 붙고 실제 시리얼로 송신. (crc=2 분기에서 `AttachModbusCRC()` 호출)
    

> 네가 올려준 Python 쪽(FrSmart/dsComm)도 같은 개념으로 **MODBUS Write Multiple/Single** 프레임을 구성해서 `.write()`로 흘려보내고 있어. PC 앱이 바뀌어도, **펌웨어가 기대하는 레지스터·형식은 동일**하니까 모니터에 보이는 바이트열이 같은 구조로 찍히는 거야.

---

## 질문별 바로 답

- **“ReadConfigProVal에서 초기화와 더불어 기본 값을 채우는 거고 dutyzero는 duty의 기본값인 0 상태?”**  
    → 초기화(메모리 잡기)는 먼저 **MFC_NSB 응답**에서 하고, **보정 파라미터와 `dutyzero`(= zduty 표)는 `ReadConfigProVal_MFC()`에서 파일을 읽어 채움**. `dutyzero`는 0이 아니라 **각 채널의 “무유량 기준 절대 듀티(zduty)”** 값들이 들어간 표야.
    
- **“SW에서 OS 거쳐 펌웨어로 신호 보낼 때, DecodeData_MFC()에서 duty에 값을 넣어주는 거야?”**  
    → 두 경우가 있어.  
    (1) 장비에서 **현재 듀티 레지스터(MFC_SPA)** 를 읽어오면 `DecodeData_MFC(MFC_SPA)`에서 **응답값을 `s_mfc.duty[]`에 채움**.  
    (2) 사용자가 UI에서 %를 정해 RUN을 누르면 `SetDutyBoard_MFC()`가 **그 %를 보정식으로 바꿔** 직접 패킷에 써서 보낸다(필요 시 `s_mfc.duty[]`는 “요청 %×100” 같은 형태로 쓰일 수 있음).
    
- *_“unsigned랑 duty/status 앞의 _는?”__  
    → `unsigned short *`는 **2바이트 부호 없는 정수들의 동적 배열**을 가리키는 **포인터**. 보드 수를 알아야 배열 길이가 정해지므로, 런타임에 malloc으로 할당하는 구조야.
    

---

필요하면 지금 쓰고 있는 **보정식(코드 그대로: xvalue 스케일, coeff 다항, (dutyzero–offset) 더함, 클램프, ×100)** 을 엑셀로 딱 맞게 옮긴 시트를 다시 정리해줄게.

- 채널별로 `zduty`는 **ConfigProVal.cfg의 값**을 넣고,
    
- `xvalue = (입력% * fscale) / 100 / 100`(코드 그대로의 이중 100 분모)로 계산해야 **펌웨어 계산과 완전히 동일**하게 나와.  
    원하면 바로 만들어 줄게 — 어느 형식(열 구성)으로 줄까?