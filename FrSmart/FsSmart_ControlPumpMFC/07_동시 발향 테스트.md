좋아요! 펌웨어는 이미 정상이라면, 지금은 “프로토콜(UI)에서 MFC(멀티플로우)까지 한 번에 테스트/모니터링”이 핵심이죠. 아래처럼 바로 옮겨 붙일 수 있는 형태로 정리해 드릴게요.

---

# 1) protocol.ui에서 MFC 기능 테스트까지 되게 만들기

`FrSmart.py`의 `UiDlg.uiDlgProtocol()`에 MFC용 버튼/입력칸만 몇 개 추가하면 됩니다. (UI 파일을 다시 열기 번거롭다면, 임시로 기존 ‘Protocol’ 화면에 버튼을 몇 개 더 배치해 쓰셔도 됩니다: `pushButton_mfc_run`, `pushButton_mfc_clean`, `pushButton_mfc_stop`, `pushButton_mfc_read_pressure`, `pushButton_mfc_set_duty_board`, `spinBox_mfc_board`, `lineEdit_duties`(“0,0,0,0,0,0” 형식), `spinBox_mfc_power`, `spinBox_mfc_time`, `spinBox_mfc_valve_freq` 등.)

아래 코드를 **그대로** `FrSmart.py`에 추가(or 대체)하세요.

```python
# ==== 0) MFC 레지스터/상수 (C 코드 값과 동일) ====
MFC_MID = 0x01
MBC_RHR = 0x03
MBC_RIP = 0x04
MBC_WSR = 0x06
MBC_WMR = 0x10

CMD_RUN   = 1
CMD_CLEAN = 2
CMD_STOP  = 3

# Input (Read Only)
MFC_FVM = 0x0FA0  # fw ver (2 words x2)
MFC_NSB = 0x0FBD  # number of solenoid boards (1~13)
MFC_CGP = 0x0FBF  # carrier gas pressure (0~140kPa) *10

# Holding (R/W)
MFC_CMD = 0x1068
MFC_RPW = 0x106A  # run pump power (%)
MFC_CPW = 0x106B  # clean pump power (%)
MFC_POT = 0x106C  # run time (sec)
MFC_COT = 0x106D  # clean time (sec)
MFC_RPD = 0x106E
MFC_CPD = 0x106F
MFC_PPF = 0x1074  # pump PWM (Hz~kHz)
MFC_VPF = 0x1075  # valve PWM

MFC_SPA = 0x1086  # board0의 포트1 duty 시작. 보드 i의 시작주소 = MFC_SPA + i*8

# ==== 1) MODBUS RTU CRC ====
def _mb_crc(data: bytes) -> bytes:
    crc = 0xFFFF
    for ch in data:
        crc ^= ch
        for _ in range(8):
            lsb = crc & 1
            crc >>= 1
            if lsb:
                crc ^= 0xA001
    return bytes([crc & 0xFF, (crc >> 8) & 0xFF])  # Low, High

# ==== 2) MODBUS RTU 프레임 빌더 ====
def mb_read(uid: int, func: int, addr: int, qty: int) -> bytes:
    p = bytes([uid, func, (addr>>8)&0xFF, addr&0xFF, (qty>>8)&0xFF, qty&0xFF])
    return p + _mb_crc(p)

def mb_write_single(uid: int, addr: int, value: int) -> bytes:
    p = bytes([uid, MBC_WSR, (addr>>8)&0xFF, addr&0xFF, (value>>8)&0xFF, value&0xFF])
    return p + _mb_crc(p)

def mb_write_multiple(uid: int, start_addr: int, words: list[int]) -> bytes:
    qty = len(words)
    payload = bytearray()
    for w in words:
        payload += bytes([(w>>8)&0xFF, w&0xFF])
    p = bytes([
        uid, MBC_WMR,
        (start_addr>>8)&0xFF, start_addr&0xFF,
        (qty>>8)&0xFF, qty&0xFF,
        len(payload)
    ]) + payload
    return p + _mb_crc(p)

# ==== 3) UiDlg에 붙이는 MFC 송신 함수들 ====
def _mfc_set_run_params(self, power: int, time_s: int, valve_khz: int|None=None):
    # 필요한 것만 설정, 변경 없음은 생략 가능
    self.write_data(mb_write_single(MFC_MID, MFC_RPW, power))
    self.write_data(mb_write_single(MFC_MID, MFC_POT, time_s))
    if valve_khz is not None:
        self.write_data(mb_write_single(MFC_MID, MFC_VPF, valve_khz))

def _mfc_set_clean_params(self, power: int, time_s: int):
    self.write_data(mb_write_single(MFC_MID, MFC_CPW, power))
    self.write_data(mb_write_single(MFC_MID, MFC_COT, time_s))

def _mfc_set_board_duties(self, board_index: int, six_duties_0to10000: list[int]):
    """
    board_index: 0-based (보드1이면 0)
    six_duties_0to10000: [포트1..포트6] 각 (0~10000) == 0.00% ~ 100.00%
    """
    if len(six_duties_0to10000) != 6:
        raise ValueError("6개 duty 필요")
    start_addr = MFC_SPA + (board_index * 8)
    self.write_data(mb_write_multiple(MFC_MID, start_addr, six_duties_0to10000))

def mfc_run(self):
    self.write_data(mb_write_single(MFC_MID, MFC_CMD, CMD_RUN))

def mfc_clean(self):
    self.write_data(mb_write_single(MFC_MID, MFC_CMD, CMD_CLEAN))

def mfc_stop(self):
    self.write_data(mb_write_single(MFC_MID, MFC_CMD, CMD_STOP))

def mfc_read_pressure(self):
    # CGP 1 word
    self.write_data(mb_read(MFC_MID, MBC_RIP, MFC_CGP, 1))

def mfc_read_nsb(self):
    # NSB 1 word
    self.write_data(mb_read(MFC_MID, MBC_RIP, MFC_NSB, 1))

# ==== 4) protocol 탭에 이벤트 연결 (uiDlgProtocol 내에서) ====
# 예: self.ui_data_protocol_dlg.pushButton_mfc_run.clicked.connect(lambda: self._ui_mfc_do_run())
def _ui_mfc_set_board(self):
    idx = self.ui_data_protocol_dlg.spinBox_mfc_board.value()  # 0,1,2...
    # "0,0,0,0,0,0" -> [int,...]
    six = [int(x.strip()) for x in self.ui_data_protocol_dlg.lineEdit_duties.text().split(",")]
    self._mfc_set_board_duties(idx, six)

def _ui_mfc_do_run(self):
    power = self.ui_data_protocol_dlg.spinBox_mfc_power.value()
    time_s = self.ui_data_protocol_dlg.spinBox_mfc_time.value()
    valve = self.ui_data_protocol_dlg.spinBox_mfc_valve_freq.value()
    self._mfc_set_run_params(power, time_s, valve)
    # 필요한 보드만 순회하며 duty 써주기 (UI에서 호출 시 먼저 _ui_mfc_set_board를 눌러도 됨)
    self.mfc_run()

def _ui_mfc_do_clean(self):
    power = self.ui_data_protocol_dlg.spinBox_mfc_power.value()
    time_s = self.ui_data_protocol_dlg.spinBox_mfc_time.value()
    self._mfc_set_clean_params(power, time_s)
    self.mfc_clean()

def _ui_mfc_do_stop(self):
    self.mfc_stop()

def _ui_mfc_read_pressure(self):
    self.mfc_read_pressure()

# UiDlg.__init__ or uiDlgProtocol() 종료쯤에 아래 바인딩만 추가:
UiDlg._mfc_set_run_params = _mfc_set_run_params
UiDlg._mfc_set_clean_params = _mfc_set_clean_params
UiDlg._mfc_set_board_duties = _mfc_set_board_duties
UiDlg.mfc_run = mfc_run
UiDlg.mfc_clean = mfc_clean
UiDlg.mfc_stop = mfc_stop
UiDlg.mfc_read_pressure = mfc_read_pressure
UiDlg.mfc_read_nsb = mfc_read_nsb
UiDlg._ui_mfc_set_board = _ui_mfc_set_board
UiDlg._ui_mfc_do_run = _ui_mfc_do_run
UiDlg._ui_mfc_do_clean = _ui_mfc_do_clean
UiDlg._ui_mfc_do_stop = _ui_mfc_do_stop
UiDlg._ui_mfc_read_pressure = _ui_mfc_read_pressure
```

> 연결 예시  
> `self.ui_data_protocol_dlg.pushButton_mfc_set_duty_board.clicked.connect(self._ui_mfc_set_board)`  
> `self.ui_data_protocol_dlg.pushButton_mfc_run.clicked.connect(self._ui_mfc_do_run)`  
> `self.ui_data_protocol_dlg.pushButton_mfc_clean.clicked.connect(self._ui_mfc_do_clean)`  
> `self.ui_data_protocol_dlg.pushButton_mfc_stop.clicked.connect(self._ui_mfc_do_stop)`  
> `self.ui_data_protocol_dlg.pushButton_mfc_read_pressure.clicked.connect(self._ui_mfc_read_pressure)`  
> `self.ui_data_protocol_dlg.pushButton_mfc_read_nsb.clicked.connect(self.mfc_read_nsb)`

이렇게만 해도 Protocol 화면에서 **보드별 6포트 duty 쓰기 → 파라미터 설정 → RUN/CLEAN/STOP → 압력 읽기**가 됩니다.

---

# 2) SW→HW 바이트 패킷(멀티플로우) 규칙 & 예시

모두 **MODBUS RTU** 입니다(현재 코드 기반 그대로).

- 공통 프레임:  
    `ID | FUNC | ADDR_H | ADDR_L | ... | CRC_L | CRC_H`
    
- CRC는 **Modbus little‑endian(Lo,Hi)**. 위 `_mb_crc` 코드 그대로 쓰면 됩니다.
    

## A. 여러 레지스터 쓰기 (WMR, 0x10: duty 6개 쓰기)

- 목적: 보드 i의 6포트 duty(각 0~10000) 한 번에 기록
    
- 주소: `MFC_SPA + i*8`
    
- 형식:  
    `ID(01) 10 AA_H AA_L 00 06 0C D1_H D1_L ... D6_H D6_L CRC_L CRC_H`
    
- 예: 보드0에 duty 2000,0,0,0,0,0
    
    ```
    01 10 10 86 00 06 0C 07 D0 00 00 00 00 00 00 00 00 00 00  CRC
    ```
    

## B. 단일 레지스터 쓰기 (WSR, 0x06: 파라미터/명령)

- 예: 러닝 파워 85% (`MFC_RPW=0x106A`)
    
    ```
    01 06 10 6A 00 55 CRC
    ```
    
- RUN 명령 (`MFC_CMD=0x1068`, 값 1)
    
    ```
    01 06 10 68 00 01 CRC
    ```
    

## C. 입력레지스터 읽기 (RIP, 0x04: 압력, NSB 등)

- 압력(1 word): `01 04 0F BF 00 01 CRC`
    
- 응답: `01 04 02 00 64 CRC` → 0x0064=100 → 100/10 = **10.0 kPa**
    

## D. 예외 응답

- `FUNC | 0x80` 가 되며, 3바이트(에러코드)로 옴. 콘솔에 그대로 표시하고 UI에 “에러코드 xx” 띄우면 됩니다.
    

---

# 3) 수신 복호화 & 콘솔/상태 표시

`readSerialData()`에서 RX hex를 찍고 있는데, 거기에 **간단 파서**를 추가하면 “무엇을 읽었나/썼나”를 UI에 같이 보여줄 수 있어요.

```python
def parseReadData(self, data: bytes):
    # 1) 콘솔 덤프(이미 있음)
    # 2) 아주 얕은 MODBUS 파싱
    if len(data) < 5:
        return
    uid = data[0]
    func = data[1]
    # 예외
    if func & 0x80:
        code = data[2]
        self._serial_console.append(f"EXCEPTION: func=0x{func:02X}, code={code}")
        return
    # 읽기 응답 (0x03/0x04)
    if func in (0x03, 0x04):
        bc = data[2]
        payload = data[3:3+bc]
        # 주소는 요청 프레임과 별개라 여기선 값만 표시
        words = [ (payload[i]<<8) | payload[i+1] for i in range(0, len(payload), 2) ]
        self._serial_console.append(f"READ {len(words)} words -> {words}")
        # 압력일 가능성: 1워드 & 최근에 mfc_read_pressure 호출 시
        if len(words)==1:
            kpa = words[0] / 10.0
            # pressure label 있으면 같이 업데이트(선택)
            # self.ui_data_protocol_dlg.label_pressure.setText(f"{kpa:.1f} kPa")
        return
    # 다중쓰기 응답(0x10)은 에코: 시작주소/카운트만 돌아옴
    if func == 0x10 and len(data) >= 8:
        addr = (data[2]<<8)|data[3]
        qty  = (data[4]<<8)|data[5]
        self._serial_console.append(f"WMR OK @0x{addr:04X}, {qty} words")
    # 단일쓰기 응답(0x06)도 에코
    if func == 0x06 and len(data) >= 8:
        addr = (data[2]<<8)|data[3]
        val  = (data[4]<<8)|data[5]
        self._serial_console.append(f"WSR OK 0x{addr:04X} = {val}")
```

> 이미 `write_data()`/`readSerialData()`가 TX/RX hex를 잘 찍고 있으니, 위처럼 몇 줄만 더하면 “사람이 읽을 수 있는 상태”를 **텍스트 콘솔에 동시에** 보여줄 수 있어요. 필요하면 `label` 하나 두고 압력(kPa), NSB(보드 수), RUN 상태 등을 갱신하면 됩니다.

---

## 추천 워크플로우 (Protocol 화면에서)

1. **연결** 버튼으로 시리얼 연결
    
2. **NSB 읽기**(선택): 보드 수 확인
    
3. 보드 인덱스/듀티 6개 입력 → **Set duty(board)**
    
    - 보드는 0부터(보드1 → 0)
        
    - 듀티는 **정수 0~10000**(=0.00%~100.00%)
        
4. 파라미터 입력(파워, 시간, 밸브주파수) → **RUN**
    
5. 압력 읽기/그래프(선택) → **Read pressure**
    
6. **STOP** 또는 **CLEAN**
    

모든 TX/RX는 콘솔에 헥사로, 그리고 간단 디코드 메시지로 동시에 뜨게 됩니다.

---

## 흔한 이슈 체크리스트

- CRC 순서(Lo, Hi) 꼭 맞추기 → 위 헬퍼 사용 권장
    
- 보드 인덱스 0‑based 주의 (C 코드가 address를 `+ 8*i` 하던 그대로)
    
- 듀티는 “word(2바이트) × 6개”로 12바이트여야 함(byte count=0x0C)
    
- 예외 응답(0x80|func) 처리: 콘솔에 코드 표기하고 멈추지 않기
    
- 읽기 응답의 값 스케일: 압력은 *10, (필요시 UI에서 나눠 표시)
    

---

필요하시면 `protocol.ui`에 들어갈 버튼/입력 위젯 이름을 딱 맞춰 드릴 수 있고, 기존 PySide6 화면에 바로 꽂히도록 최소 세트도 만들어 드릴게요. 전체 적용 중 막히는 지점(예: UI 시그널 연결, 보드 인덱스/범위, 듀티 스케일링)이 있으면 해당 부분 로그(TX/RX 덤프 포함)만 주시면 거기에 맞춰 바로 수정해 드리겠습니다.