맞아요. 지금 펌웨어는 **여러 설정을 “각 레지스터 그룹별”로 따로 쓰는 MODBUS 방식**이라서, SW에서도 **한 줄에 몰아서 보내는 게 아니라 5개의 프레임을 순서대로** 보내야 합니다.

## 보내는 순서(당신 로그와 동일)

1. **발향세기**(Pump Power) — `0x106A` 단일 쓰기 (0x06)  
    `01 06 10 6A 00 55 6D 29` → 값 `0x0055 = 85`
    
2. **발향시간(딜레이/런타임)** — `0x106C` 단일 쓰기 (0x06)  
    `01 06 10 6C 00 05 8D 14` → 값 `0x0005 = 5`
    
3. **1번 보드(채널 11~16) Duty 묶음** — `0x1086` 다중 쓰기 (0x10, QOR=6)  
    `01 10 10 86 00 06 0C 12 DC 00 00 00 00 00 00 00 00 00 00 4A BB`  
    → CH11=4828(0x12DC), CH12~16=0
    
4. **2번 보드(채널 21~26) Duty 묶음** — `0x108E` 다중 쓰기 (0x10, QOR=6)  
    `01 10 10 8E 00 06 0C 11 65 00 00 11 01 00 00 00 00 00 00 E1 27`  
    → CH21=4453(0x1165), CH23=4353(0x1101), 그 외 0
    
5. **실행 명령(발향 시작)** — `0x1068` 단일 쓰기 (0x06)  
    `01 06 10 68 00 01 CD 16` → RUN=1
    

> 한마디로: **Power → Time → 보드1 Duty → 보드2 Duty → RUN** 순서로 **5번** 보냅니다.

---

## 왜 한 번에 못 보내나?

- 펌웨어가 **각 레지스터 블록**에 대해 **고정 주소**(0x106A, 0x106C, 0x1086, 0x108E, 0x1068)를 **기대**하고 있고,
    
- NF처럼 “여러 의미의 파라미터를 하나의 큰 구조로” 받도록 설계돼 있지 않기 때문입니다.
    
- 따라서 **MODBUS 표준**대로, **단일 레지스터(0x06) 또는 다중 레지스터(0x10)** 를 **블록별로** 쓰는 방식이 맞습니다.
    

---

## 실전 팁

- **응답 확인**: 0x06/0x10 요청마다 **정상 응답**(에러 비트 없는 기능코드)이 돌아오는지 확인하고 다음 프레임을 보내세요. (에러면 재시도)
    
- **간격**: 장치가 빠르게 처리합니다만, 프레임 간 **수 ms~수십 ms** 텀을 두면 안정적입니다(타임아웃 설정 필수).
    
- **스킵 최적화**: 파워/시간이 이전과 동일하면 1)~2)는 생략 가능. Duty가 한 보드만 바뀌면 해당 보드만 0x10 전송.
    
- **클리어**: 종료 시 RUN=0(또는 장치가 자동으로 0으로 복귀하는지 확인)도 같은 방식으로 0x1068에 써 줍니다.
    

---

## SW 의사코드 예시 (파이썬)

```python
def send_mfc_sequence(port, ch11_16, ch21_26, power, runtime):
    # 1) power
    write_single(port, addr=0x106A, value=power)     # 0x06
    check_ack()

    # 2) runtime
    write_single(port, addr=0x106C, value=runtime)   # 0x06
    check_ack()

    # 3) board #1 (11~16)
    write_multiple(port, addr=0x1086, regs=ch11_16)  # 6 regs, 0x10
    check_ack()

    # 4) board #2 (21~26)
    write_multiple(port, addr=0x108E, regs=ch21_26)  # 6 regs, 0x10
    check_ack()

    # 5) run
    write_single(port, addr=0x1068, value=0x0001)    # 0x06
    check_ack()
```

- `ch11_16`, `ch21_26`는 **[6개 정수] 리스트**(각각 DEC= duty%×100), 없다면 0 채움.
    
- `write_single`/`write_multiple`는 **MODBUS RTU** 프레임(슬레이브ID, Func, Addr, Data, CRC)을 만들어 포트에 `write()`.
    

---

원하면, 네가 쓰는 프레임 생성기(NF용)와 동일한 스타일로 **MFC용 5프레임**을 **바로 찍어주는 헬퍼**도 만들어줄게.  
또는 엑셀/시트에서 **퍼센트 → DEC/HEX → 0x10 패킷**까지 자동으로 조립해 **붙여넣기만 하면 되는 헤X 문자열**로 뽑아주도록 구성할 수도 있어요.