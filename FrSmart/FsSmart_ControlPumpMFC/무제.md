
---

## ■ 전체 통합 흐름: 명령 생성 → 송신 → 펌웨어 처리 → 응답 수신 → 해석/표시
┌──────────────┐
│  PC SW (UI)  │
└──────┬───────┘
       │ ① 사용자가 UI에서 명령(발향/세정/둘다) + 향 번호 + 세기/시간/딜레이 입력
       ▼
─────────────────────────────────────────────
      [명령 데이터 준비]
         ├─ s_scent 구조체에 cmdid(명령번호), scentno(향 번호),
         │    power, period, delay 등 값 저장
         └─ WriteSingleReg / WriteMultiReg / SetDutyBoard 같은
             제어 함수에서 s_serial.send[] 버퍼에 바이트 단위로 패킷 구성
             (MODBUS 규격: ID + 함수코드 + 주소 + 데이터 + CRC)
─────────────────────────────────────────────
       ▼
┌─────────────────────┐
│   SendToCom(s_serial)│                                    (PC SW)
└─────────┬───────────┘
          │
          │ CRC 부착 → 프로토콜 인코딩(SLIP/종결자) → 디버그 출력
          ▼
     ComWrt(port, send[], sendbyte)   ← OS 시리얼 드라이버 호출
          │
─────────────────────────────────────────────
[Windows OS / 시리얼 드라이버]
          │ UART/USB-Serial 하드웨어 통해 바이트 스트림 전송
─────────────────────────────────────────────
          ▼
┌──────────────────────────┐
│   MCU 펌웨어(UART 수신)   │
└──────────┬───────────────┘
           │
           │ UART RX 인터럽트/DMA → 수신 버퍼 적재
           │ MODBUS 스택이 CRC·주소·함수코드 검사 후 데이터 해석
           │ cmdid, scentno, power, duty 값으로 매니폴드(밸브/펌프) 제어
           │ 하드웨어 동작(발향/세정) 수행
           ▼
      응답 패킷 생성 (요청 에코/상태/데이터) → UART TX 송신
─────────────────────────────────────────────
          ▲
[Windows OS / 시리얼 드라이버]
          │
     ReadFromCom(s_serial) 호출
          │ 포트의 입력 큐에서 바이트 읽기
          │ ⇒ FlushInQ()로 잔여 데이터 제거/초기화
─────────────────────────────────────────────
          ▲
┌─────────┴───────────┐
│     PC SW 수신 처리 │
└─────────────────────┘
          │
          ├─ DecodePacket() : 예외 응답(에러 코드)인지 판별 → Error_MFC 호출 가능
          └─ DecodeData_MFC() : 정상 응답이면 주소별로 값 파싱
               → s_mfc 구조체 저장(보드 수, 포트 상태, duty 값, 압력 등)
               → UI 컨트롤 값 반영, 그래프 표시


---

## ■ 핵심 개념 정리

1. **명령 생성 주체**
    
    - PC 소프트웨어(C 코드/Python UI)에서 `s_scent` 또는 제어 함수들이 패킷 구성
        
    - `s_serial.send[]` 버퍼에 0번 인덱스부터 순차적으로 바이트 넣음
        
2. **전송**
    
    - `SendToCom()` → CRC, 프로토콜 처리 후 → OS 드라이버 → UART → MCU
        
3. **펌웨어 처리**
    
    - UART 하드웨어가 바이트 수신
        
    - MODBUS 스택이 분석 → 하드웨어 제어 로직 실행
        
4. **응답 수신**
    
    - MCU가 처리 결과를 MODBUS 응답 패킷으로 송신
        
    - PC에서 `ReadFromCom()`로 읽어 `s_serial.read[]` 채움
        
5. **응답 해석**
    
    - `DecodePacket()` : 패킷이 정상인지(에러 여부) 판정
        
    - `DecodeData_MFC()` : 데이터 값을 구조체에 저장 & UI 업데이트
        
6. **FlushInQ의 중요성**
    
    - Read 후 포트 입력 버퍼(큐)를 비워서 이전/쓰레기 데이터가 다음 명령 응답에 섞이지 않게 함
        

---

## ■ 기억 포인트

- **SendToCom** → “보내는 관문”
    
- **ReadFromCom** → “받는 관문”
    
- PC 쪽 `SendToCom`과 MCU 쪽(펌웨어)에서 쓰는 Send 함수는 **이름만 같고 서로 다른 구현**
    
- `DecodePacket`/`DecodeData_MFC`는 **제어 명령이 아니라 응답 해석 전용**
    
- 프로토콜전송 직후 Read하는 이유는 요청-응답 방식이 기본이기 때문
    

---

이제 이 그림만 기억해 두시면, 앞으로 C 코드나 Python 코드에서 **"이 함수가 송신 쪽인지, 수신 쪽인지, 해석 쪽인지"**를 바로 구분하실 수 있을 거예요.

원하시면 제가 **MFC_SPA를 이용한 2보드(12밸브) 개별 제어 주소표**도 같이 만들어 드릴 수 있습니다.  
그 표를 보면 각 포트별로 몇 번 주소를 써야 하는지 한눈에 확인 가능합니다.  
그것도 해드릴까요?