

---

## 1. 참고: 기본 MODBUS 패킷 구조

- 첫 바이트: 슬레이브 장치 주소 (보통 0x01)
    
- 두번째 바이트: 함수 코드 (0x06=Write Single Register, 0x10=Write Multiple Registers)
    
- 다음 2바이트: 레지스터 시작 주소
    
- 그 다음 2바이트 (단일 쓰기) 혹은 2바이트씩 여러 개(다중 쓰기)
    
- 마지막 2바이트: CRC (체크섬)
    

---

## 2. 각 패킷 별 상세 해석

## (1) `01 06 10 6a 00 55 6d 29`

- **01**: 슬레이브 주소
    
- **06**: Write Single Register (단일 레지스터 쓰기)
    
- **10 6a**: 주소 0x106A (10진수 4202)
    
- **00 55**: 데이터 값 0x55 (85 decimal)
    
- **6d 29**: CRC
    

**의미:**

- 0x106A 레지스터에 85(0x55) 값을 씀
    
- MFC 구성에서 보통 `0x1068~0x106D` 근처 주소는 펌프/펌프 파워, 런타임, 명령 코드 등 단일 제어용
    
    - 0x106A는 펌프 전력(power) 또는 related 파라미터일 가능성 높음
        

---

## (2) `01 06 10 6c 00 05 8d 14`

- **01**: 슬레이브 주소
    
- **06**: Write Single Register
    
- **10 6c**: 주소 0x106C (4204 decimal)
    
- **00 05**: 데이터 값 5
    
- **8d 14**: CRC
    

**의미:**

- 0x106C 주소에 5 쓰기
    
- 0x106C는 아마 런타임(runtime)이나 딜레이, 상태 플래그 등 단일 값 제어 레지스터
    

---

## (3) `01 10 10 86 00 06 0c 12 dc 00 00 00 00 00 00 00 00 00 00 4a bb`

- **01**: 슬레이브 주소
    
- **10**: Write Multiple Registers (다중 레지스터 쓰기)
    
- **10 86**: 시작 주소 0x1086 (4230 decimal) — 첫번째 보드 6개 채널 duty 시작 주소
    
- **00 06**: 6개의 레지스터 (6채널)
    
- **0c**: 바이트 수 (6 x 2 = 12 바이트)
    
- 다음 12 바이트: `12 dc 00 00 00 00 00 00 00 00 00 00`
    
- **4a bb**: CRC
    

**의미:**

- 첫 번째 솔레노이드 보드 6개 밸브에 쓰는 duty 값 패킷
    
- `12 dc` (hex 0x12DC = 4828 decimal)은 첫 번째 밸브의 보정된 duty 값으로 보임
    
- 나머지는 모두 0으로 채워진 상태 (즉, 첫 채널만 4828, 나머지 0)
    

---

## (4) `01 10 10 8e 00 06 0c 11 65 00 00 11 01 00 00 00 00 00 00 e1 27`

- **01**: 슬레이브 주소
    
- **10**: Write Multiple Registers
    
- **10 8e**: 시작 주소 0x108E (4238 decimal) — 두번째 보드 6채널 duty 시작 주소
    
- **00 06**: 6개의 레지스터
    
- **0c**: 바이트 수
    
- 데이터: `11 65 00 00 11 01 00 00 00 00 00 00`
    
- CRC: `e1 27`
    

**의미:**

- 두 번째 보드 6개 포트 duty 값 출력 패킷
    
- 첫 채널 값 `0x1165` (4453 decimal), 세 번째 채널 값 `0x1101` (4353 decimal) 정도로 보정됨
    
- 나머지 채널은 0 (즉, 21번, 23번 라인에 duty 준 상태 반영 가능)
    

---

## (5) `01 06 10 68 00 01 cd 16`

- **01**: 슬레이브 주소
    
- **06**: Write Single Register
    
- **10 68**: 주소 0x1068 (4200 decimal) — 명령 코드 레지스터 위치
    
- **00 01**: 값 1 (명령 실행, RUN 등)
    
- **cd 16**: CRC
    

**의미:**

- 명령 코드 레지스터에 1을 씀 → 발향(run) 신호 발송
    
- 이 신호로 위의 duty 설정값들이 하드웨어에 반영되기 시작
    

---

## 3. 전체 시퀀스(동작 흐름 요약)

1. **센서 조회 반복 명령** `01 04 0f bf 00 01 03 3a` (압력 센서 반복 읽기) 상태에서 벗어나 여러 명령 쓰기 시작
    
2. 단일 레지스터 쓰기로 펌프 세팅(`0x106A`, `0x106C`)값 조정
    
3. 다중 레지스터 쓰기로 첫 번째 보드 duty 값 전송 (6채널)
    
4. 다중 레지스터 쓰기로 두 번째 보드 duty 값 전송 (6채널)
    
5. 명령 코드(`0x1068`)에 발향 실행 신호 쓰기 → 장비가 duty 값을 기반으로 동작 시작
    

---

1. 첫 번째 솔레노이드 보드 입력값 0x12DC(16진수)는 10진수로 4828입니다.  
    그런데 사용자가 입력한 40(%)는 16진수로 0x28인데, 두 값은 같지 않습니다.  
    이는 단순히 40을 16진수로 변환한 값이 아니라, 내부적으로 보정 함수(예: 5차 다항식 및 오프셋 적용)와 스케일링을 거쳐 40% 주어진 입력이 실제 하드웨어 제어 신호에 맞게 변환된 결과이기 때문입니다.  
    즉, 40% 입력값이 하드웨어에 주는 duty 신호로는 약 4828(0x12DC) 값으로 매핑된 것입니다.
    
2. 두 번째 솔레노이드 보드에서 21번, 23번 라인에 30%씩 값을 주었는데, 보낸 16진수 값은 각각 0x1165(4453), 0x1101(4353)로 다릅니다.  
    이 역시 동일한 30% 입력임에도 불구하고 보정이나 각 밸브별 특성 차이(오프셋, 다항식 계수 등이 일부 다름) 때문에 값이 다소 다르게 산출된 것입니다.  
    즉, 두 채널 모두 30%이지만, 보정 공식 및 하드웨어 특성 반영 시 미세한 차이가 발생하는 것이 정상입니다.
    

아래 표는 정리된 내용입니다:

|채널|입력값(%)|16진수 표기|10진수(해석값)|비고|
|---|---|---|---|---|
|1번 (보드1)|40|12 DC|4828|보정 함수 적용 후 변환된 실 신호값|
|1번 (보드2)|30|11 65|4453|보정 및 오프셋 적용된 신호값|
|3번 (보드2)|30|11 01|4353|미세한 차이로 값이 조금 다름|

즉, MFC 소프트웨어에서는 사용자 입력(0~100%)을 그대로 쓰지 않고, 내부 보정과 하드웨어 특성 반영 과정에서 신호값을 계산하여 MODBUS 메시지로 전송합니다. 따라서 16진수 값들은 직접 입력값과 일치하지 않는 대신, 실제 밸브 제어를 위한 정밀한 제어 신호를 의미합니다.

