
# 개요

- **개발환경**: NI LabWindows/CVI 기반(CVI 런타임, UIR 패널 사용) + RS232(Modbus) 통신으로 **펌프·솔레노이드 밸브 보드**를 제어하는 GUI 프로그램. 메인 패널과 압력 모니터 패널 2개를 띄움 .
    
- **핵심 구조체** `S_MFC`: 솔레노이드 보드 개수/라인 수, 듀티·상태 배열, 보정계수(fscale/offset/coeff[6]/dutyzero), 실행 파라미터(cmdid/power/freq/runtime) 등을 보관 .
    

# 시작 시퀀스(프로그램 부팅)

1. CVI 런타임 초기화 → UIR 패널 로드 & 표시 → `InitProcess()` 호출 .
    
2. `InitProcess()`
    
    - 직렬포트 설정 로드 → 포트 오픈 → 1.5초 대기 → `InitProcess_MFC()` 실행. 성공 시 `InitConfig_MFC()`와 타이머 활성화 .
        
3. `InitProcess_MFC()`
    
    - **펌웨어 버전**, **솔레노이드 보드 개수(NSB)** 읽기 → NSB를 `DecodeData_MFC()`로 디코딩(이 시점에 동적 배열들 malloc) .
        
4. `InitConfig_MFC()`
    
    - UI상의 6/12개 듀티 입력 컨트롤 핸들 인덱싱, 상태 플래그 초기화, 합계 듀티 0으로 설정 → **보정 파일**(`ConfigProVal.cfg`) 읽어 fscale/offset/coeff[6]/dutyzero[*] 로드 → [Run] 버튼 활성화 .
        
5. 주기 타이머는 **Carrier Gas Pressure**(kPa×0.1)를 폴링해서 패널 값과 스트립차트 갱신 .
    

# 파라미터/보정 파일 로딩

- `ConfigProVal.cfg`에서 순서대로  
    `fscale`(full scale), `offset`, `coeff[0..5]`(6차 다항식 계수), **보드별 6포트의 zero-duty 보정값**(zduty[6])을 읽어들임 .  
    → 이 값들은 뒤의 **듀티 변환 로직**에 쓰임.
    

# 통신 프로토콜(Modbus over RS232)

- **읽기**: `ReadRegister_MFC(readcmd, addr, nRegs)` → [ID, CMD, AddrHi, AddrLo, NHi, NLo] 전송, 응답 수신 .
    
- **단일 레지스터 쓰기**: `WriteSingleReg_MFC(addr, value)` .
    
- **여러 레지스터 쓰기(6개 포트 듀티 한번에)**: `SetDutyBoard_MFC()` 내부에서 **Write Multiple Registers** 사용(MBC_WMR) .
    
- 주요 레지스터/명령 상수는 헤더에 정의:  
    `MFC_CMD`, `MFC_RPW`(Run Pump %), `MFC_POT`(Run On Time), `MFC_VPF`(Valve PWM Freq), `MFC_SPA`(포트 듀티 베이스 주소)… .
    

# 듀티 계산(보정) 로직의 핵심

- **절대/상대 모드**: UI의 `CPL_SAD` 체크 상태로 결정.
    
    - **상대 모드**(sad=0): 사용자가 입력한 듀티(%)를 보정식으로 **변환**해서 보드에 씀.
        
    - **절대 모드**(sad=1): 입력값을 **그대로**(×100) 보드에 씀.
        
- 변환 식(상대 모드):
    
    1. `xvalue = (duty/100) * (fscale/100)`
        
    2. `fduty = Σ_{j=0..5} coeff[j] * pow(xvalue, j)`
        
    3. 보정: `fduty += (dutyzero[i] - offset)`, 반올림 보조 `+0.005`
        
    4. 클램프: `fduty <= dutyzero[i] → 0`, `fduty > 100 → 100`
        
    5. 전송 단위: 정수 **0~10000**(= %×100)로 변환해 상·하위 바이트 전송 .
        
- 한 번 호출 시 **보드당 6포트** 듀티를 연속으로 써서 효율 ↑(레지스터 카운트 0x06, 데이터 바이트 0x0C) .
    

# UI 이벤트 흐름

- **Run 버튼(`C_RunProcess`)**:
    
    - 합계 듀티(sumduty) 0이면 경고음(비프) 후 리턴.
        
    - 바뀐 값만 개별 레지스터 쓰기: RunPump%, RunTime(sec), ValvePWM(kHz).
        
    - 모든 보드에 듀티 일괄 적용 → `MFC_CMD=CMD_RUN` 송신.
        
    - 러닝 타이머 가동, [Run]/[Stop] 버튼 상태 갱신 .
        
- **Stop 버튼**: `MFC_CMD=CMD_STOP` 전송 후 UI 복귀 .
    
- **Sum 변경(`C_SumLineValue`)**: 각 라인의 듀티(실수 %)를 읽어 **내부 듀티 배열에 ×100 정수**로 저장, 합계가 100%면 파란색/그 외 빨간색 표시 .
    
- **압력 차트 토글**: 보조 패널을 띄우거나 숨김, 버튼 라벨 토글 .
    
- **오류 처리**: 응답 바이트의 에러 비트(0x80) 확인 후 에러코드→문자열 매핑하여 표시(예: CHECKSUM_ERROR, VALVE_PWM_RANGE_ERROR 등) .
    

# 잠재 버그·주의 포인트(중요)

1. **배열 오버런 가능성(치명)**
    
    - `s_mfc.duty`는 **보드당 6개** 크기로 malloc 하였는데, `DecodeData_MFC(MFC_SPA)`에서 **보드당 8개**를 읽어 그대로 `s_mfc.duty[i]`에 저장함 → **오버플로우 위험**.
        
        - 할당: `tnsbd * 6` 요소
            
        - 대입: `for (i=0; i<tnsbd * 8; i++) s_mfc.duty[i] = ...` .  
            **대책**:
            
    - (A) 읽기 루프를 `tnsbd*6`으로 제한, 또는
        
    - (B) `s_mfc.duty`를 `tnsbd*8`로 재할당하고 포트 외 2워드는 별도 멤버에 보관.
        
2. **메모리 해제 안전성**
    
    - `QuitProcess()`에서 포인터들을 무조건 `free()` → 초기화 실패 시/부분 할당 시 **이중 free** 가능성은 낮지만, **NULL 초기화** 습관/해제 후 NULL 대입 권장 .
        
3. **보정 경계값 처리**
    
    - `fduty <= dutyzero → 0` 규칙 때문에 **근접 구간에서 급격한 0 처리** 발생 가능. 소량 분사 요구 시 **히스테리시스**(예: ±0.2%) 도입 검토 .
        
4. **유닛 표기 혼선**
    
    - 주석에 Valve PWM 주파수 단위 설명이 **kHz**로 되어 있으나 범위 주석은 “1 Hz–40 kHz”. UI/문서에서 단위를 **명시 일치**할 것 .
        
5. **합계 100% 강제 검증 없음**
    
    - 색상만 바꾸고 **실행은 가능**. 하드웨어 제약이 있다면 Run 이전에 **합계=100% 강제** 혹은 경고/차단 로직 추가 권장 .
        
6. **Config 파일 미존재 시**
    
    - `OpenFile` 실패하면 조용히 return. 최소한 UI에 **보정 미적용 경고**를 표시하는 편이 원인 파악에 도움 .
        

# 빠른 테스트 체크리스트

- 통신 초기화 후 NSB가 올바르게 표시/배열이 정상 할당되는지(디버그 로그/메모리 검사) .
    
- `SetDutyBoard_MFC`가 **sad=0/1** 모두에서 기대치대로 바이트를 구성하는지(레지스터 개수 0x06, 데이터 바이트 0x0C) .
    
- 압력 폴링이 주기적으로 들어오고 kPa×0.1 스케일이 맞는지(예: 101.3kPa → 1013) .
    
- 에러코드 수신 시 메시지가 즉시 UI에 뜨는지(예: CHECKSUM_ERROR) .
    

---
