사용자가 문의한 "소프트웨어에서 `write` 함수로 데이터를 보낸 후, 펌웨어에서 데이터를 받는 함수와 그 데이터를 해석하는 부분"에 대해, 지금까지 제공된 `ControlPumpMFC.c`와 관련 파일을 바탕으로 답변드립니다.

---

## 1. 데이터 전송 (write) 후 펌웨어 데이터 수신 함수 위치

- `ControlPumpMFC.c` 내에서 데이터 전송은 `SendToCom(&s_serial)` 함수 호출로 이루어집니다.
    
- `SendToCom()`은 `ConfigCOM.c`에 구현되어 시리얼 포트로 데이터를 전송하는 역할을 하며, 내부적으로는 OS의 통신 API 사용(예: `ComWrt()`).
    
- 데이터 수신은 `ReadFromCom(&s_serial)` 함수에서 수행합니다. 이 함수 역시 `ConfigCOM.c`에 있으며, 시리얼 포트 버퍼에서 데이터를 읽어 들입니다.
    

즉,

- **데이터 보내기:** `SendToCom(&s_serial)`
    
- **데이터 읽기:** `ReadFromCom(&s_serial)`
    

이 둘은 `ControlPumpMFC.c` 내 `ReadRegister_MFC()`, `WriteSingleReg_MFC()`, `SetDutyBoard_MFC()` 등에서 호출되어 각각 MODBUS 명령 패킷을 전송하고 응답을 받도록 되어 있습니다.

---

## 2. 펌웨어에서 받은 데이터 해석 함수

- 수신된 데이터는 `DecodePacket()` 함수가 처리합니다.
    
- `DecodePacket()`은 `ControlPumpMFC.c`에 선언되어 있고, 수신된 패킷을 해석하는 내부 로직이 구현되어 있습니다.
    
- 더 구체적으로, `DecodeData_MFC(unsigned short add, unsigned short qtres)` 함수가 해석 작업을 합니다.
    

`DecodeData_MFC`는 MODBUS 응답 패킷에서 특정 주소 범위(`add`부터 `qtres` 개수) 데이터를 추출하여, 내부 구조체 `s_mfc`의 해당 필드에 값을 저장합니다. 예를 들어,

- 보드 개수(`MFC_NSB`)를 읽은 경우 `s_mfc.tnsbd`에 저장
    
- 펌웨어 버전 등 주요 상태 값을 내부 변수에 할당
    

---

## 3. 요약된 관계 및 흐름

|단계|함수명|역할|
|---|---|---|
|1|`WriteSingleReg_MFC()`, `SetDutyBoard_MFC()`, `ReadRegister_MFC()`|MODBUS 명령 패킷 생성 및 `SendToCom()` 호출하여 데이터 전송|
|2|`SendToCom()` (ConfigCOM.c)|시리얼 포트로 데이터 전송(내부 `ComWrt()` 호출)|
|3|`ReadFromCom()` (ConfigCOM.c)|시리얼 포트에서 응답 데이터 수신|
|4|`DecodePacket()`|수신된 MODBUS 패킷 해석 호출|
|5|`DecodeData_MFC()`|MODBUS 응답 데이터별로 구조체 `s_mfc`에 상태/값 저장|

---

## 추가 참고

- `DecodePacket()` 내부에서는 수신 버퍼의 CRC 검사, 프로토콜별 패킷 필드 체크 등이 수행되며, 정상 패킷일 경우 `DecodeData_MFC()`를 호출해 데이터 내용을 분석합니다.
    
- `DecodeData_MFC()`는 주소 기반으로 분기하며, 읽은 값들을 `s_mfc` 구조체 필드에 저장하여 이후 UI 갱신 및 상태 판단 등에 사용됩니다.
    

---


## 1. FrSmart.py에서 시리얼 객체 생성 및 스레드 연결 과정

- `FrSmart.py` 내 `setSerialReadThread()` 함수가 실행되면,
    
    - `serial.Serial()` (pySerial의 시리얼 포트 객체)을 생성합니다 (`self._serial`).
        
    - 이 `self._serial` 객체를 인자로 받아 `dsSerial.SerialReadThread(self._serial)`이라는 QThread 기반 스레드를 만듭니다.
        
    - `SerialReadThread` 내부에서는 `self._serial.readline()` 등의 함수로 계속 데이터 수신을 대기합니다.
        
    - 데이터가 수신되면 `Signal` 시그널을 발행하고, 이 시그널은 Lamda 함수로 연결되어 결국 `FrSmart.py`의 `readSerialData()`가 호출됩니다.
        

즉,  
`FrSmart`의 시리얼 객체 → `dsSerial` 스레드에 연결 → 수신 시그널 발생 → `readSerialData()` 호출

---

## 2. FrSmart.py에서 쓰는 쓰기 작업

- FrSmart.py 내에서 `self._serial.write(wdata)` 호출하여 바이트열(`wdata`)을 시리얼 포트로 전송합니다.
    
- 이 `wdata`는 `dsComm.py`에서 생성한 MODBUS 프로토콜 패킷이며, 내부적으로 `sendMsgForEmitClean()` 같은 함수에서 ID, 함수 코드, 주소, 데이터를 패킹하고 CRC를 붙여 만든 완전한 메시지입니다.
    
- `self._serial.write()`는 pySerial 라이브러리의 저수준 쓰기 함수로, OS 시리얼 드라이버를 통해 실제 하드웨어(펌웨어 연결된 UART 등)에 전달됩니다.
    

---

## 3. 펌웨어 측(modbus device)에서 데이터 수신 및 해석 경로

- 펌웨어(임베디드 장치)가 시리얼 포트(USART 등)로부터 원시 MODBUS 데이터를 먼저 하드웨어 레벨에서 받습니다(이 부분은 펌웨어 코드가 필요하지만, 제공된 자료에는 펌웨어 내부 시리얼 입출력은 없고 PC 측 코드만 있음).
    
- 펌웨어에서 받은 데이터는 ESP 또는 내장 MCU의 MODBUS 프로토콜 스택으로 입력되고,
    

---

## 4. PC 측(CVI) `ControlPumpMFC.c` 코드 내에서 데이터 수신 및 해석

- PC 프로그램에서 `serial` 드라이버(또는 CVI 환경의 `ReadFromCom()` 같은 함수)가 시리얼 포트의 바이트 스트림을 수신하여 버퍼에 저장합니다.
    
- 수신된 데이터 패킷은 `DecodePacket()` 함수에서 MODBUS 프로토콜 규격에 따라 체크 및 파싱됩니다.
    
- 파싱된 데이터는 `DecodeData_MFC(unsigned short add, unsigned short qtres)` 함수로 전달되어 내부 구조체(`s_mfc`) 등으로 상태 값이 해석·저장됩니다.
    

즉,

- FrSmart.py → `self._serial.write(wdata)` (MODBUS 요청 전송)
    
- 펌웨어 → 이 요청을 UART 레벨로 받고 동작
    
- 펌웨어 → 응답을 다시 UART로 PC에 전송
    
- FrSmart.py → 스레드(`SerialReadThread`)가 수신 후 시그널로 `readSerialData()` 호출
    
- PC 프로그램 CVI 등(또는 Python 쪽 파싱이 별도라면) → `DecodePacket()`, `DecodeData_MFC()` 함수 계층에서 패킷 해석
    

---

## 5. 질문에 대한 간단 답변

> FrSmart.py에서 `self._serial.write(wdata)`로 보낸 `wdata`는 펌웨어에서 UART를 통해 받고,  
> 이 데이터는 펌웨어 내 MODBUS 스택에서 처리되어 장치가 동작하며,  
> 펌웨어가 보내는 응답 데이터는 PC 쪽에서 `DecodePacket()`과 `DecodeData_MFC()` 함수에서 최종적으로 해석됩니다.

---