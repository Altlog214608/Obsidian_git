---
aliases:
  - 32_8/18
---
SingleRegister

MultiRegister

MFC_ MID, MBC_WMR, 시작 주소, 레지스터 개수, 데이터 바이트 수, 데이터(duty), MODBUS CRC

MFC MODBUS 통신에서 명령어 패킷 바이트 조립을 C 코드 형태로 좀 더 자세히 설명드리겠습니다.  
특히, **Write Single Register(0x06)** 와 **Write Multiple Registers(0x10)** 명령의 바이트 배열 조립 방식과 값 전달 형태에 집중합니다.


---
사용자께서 주신 두 NF 스타일 함수(파이썬 기반) 구조를  
MFC MODBUS 제어방식에 맞게 수정하는 예시를 드리겠습니다.

***

# 1. NF 명령함수 (원본 구조 요약)

### NF 함수 (전체 파라미터 한번에 묶음)

```python
def sendMsgForEmitClean(id, func, address, qor, data_length,
                        data_command, data_scent_no, data_scent_pump_power, data_clean_pump_power,
                        data_scent_period, data_clean_period, data_scent_delay, data_cleanup_delay):
    # ... 전체 파라미터를 한번에 바이트화 + CRC 포함 ...

def requestScentNo(self, scent_no, command):
    sendMsg= dsComm.sendMsgForEmitClean(id=1, 
                                       func=16, 
                                       address=dsComm.ADDRESS_RUN_CLEAR,
                                       qor=8,
                                       data_length=16,
                                       data_command=command,
                                       data_scent_no=scent_no,
                                       data_scent_pump_power=...,
                                       data_clean_pump_power=...,
                                       data_scent_period=...,
                                       data_clean_period=...,
                                       data_scent_delay=...,
                                       data_cleanup_delay=...)
    self.write_data(sendMsg)
```

***

# 2. MFC MODBUS 스타일로 재구성

MFC 제어는 **각 명령파라미터를 MODBUS 레지스터 별로, 여러 번 나눠서 쓴다**는 점에 맞게 아래 예시로 분리 구현합니다.

```python
# Helper: MODBUS 단일 레지스터 쓰기 (0x06)
def write_single_register(modbus_id, register_address, value):
    # 바이트 조립 및 CRC 등 포함 (예: WriteSingeRes_MODBUS 호출 형태)
    pass

# Helper: MODBUS 다중 레지스터 쓰기 (0x10)
def write_multiple_registers(modbus_id, start_address, values):
    # 바이트 조립 및 CRC 포함 (예: SetDutyBoard_MFC에서 duty 배열 씀)
    pass

# MFC 제어용 통합 실행 함수 예시
def run_mfc(modbus_id,
            power, runtime,
            duty_board1_values, duty_board2_values,
            command):
    # 1) 펌프 파워 (단일 레지스터)
    write_single_register(modbus_id, 0x106A, power)

    # 2) 운전 시간 (단일 레지스터)
    write_single_register(modbus_id, 0x106C, runtime)

    # 3) 첫 번째 솔레노이드 보드 duty 다중 레지스터
    write_multiple_registers(modbus_id, 0x1086, duty_board1_values)

    # 4) 두 번째 솔레노이드 보드 duty 다중 레지스터
    write_multiple_registers(modbus_id, 0x108E, duty_board2_values)

    # 5) 실행 명령 (RUN / CLEAN 등)
    write_single_register(modbus_id, 0x1068, command)
```

***

# 3. 구현 시 참고

- NF와 달리 **명령별로 개별 패킷을 만들어서 각각 송신**한다는 점 유의  
- `write_single_register()` 와 `write_multiple_registers()` 는 내부적으로 C 코드의 `WriteSingleReg_MFC()`, `SetDutyBoard_MFC()` 같은 기능 수행  
- `duty_boardX_values` 는 각각 6채널씩 duty 값 리스트 (0~10000 범위에서 보정값 포함 가능)  
- `modbus_id` 는 보통 1 (MFC_MID)

***

필요하시면 위 Python 함수 내부 조립 로직, 혹은 C 소스와 연동 예시도 추가로 도와드릴 수 있습니다.




---
***

# 1. Write Single Register (0x06) 바이트 조립 예

```c
void WriteSingleReg_MFC(unsigned short add, unsigned short value)
{
    int index = 0;

    s_serial.send[index++] = MFC_MID;     // 슬레이브 ID (ex: 0x01)
    s_serial.send[index++] = MBC_WSR;     // MODBUS 명령 0x06 (Write Single Register)
    s_serial.send[index++] = (unsigned char)(add >> 8) & 0xFF; // 레지스터 주소 상위 바이트
    s_serial.send[index++] = (unsigned char)(add & 0xFF);      // 레지스터 주소 하위 바이트
    s_serial.send[index++] = (unsigned char)(value >> 8) & 0xFF; // 값 상위 바이트
    s_serial.send[index++] = (unsigned char)(value & 0xFF);      // 값 하위 바이트

    s_serial.sendbyte = index;  // 전체 바이트 수

    AttachModbusCRC(s_serial.sendbyte, s_serial.send);  // CRC16 추가

    SendToCom(&s_serial);  // 송신 함수 호출
    ReadFromCom(&s_serial);  // 응답 수신 및 처리
}
```

- **패킷 구조 (총 8바이트 = 6 + 2CRC)**  
  | ID(1B) | Func(1B) | Addr Hi(1B) | Addr Lo(1B) | Val Hi(1B) | Val Lo(1B) | CRC Lo(1B) | CRC Hi(1B) |

***

# 2. Write Multiple Registers (0x10) 바이트 조립 예

```c
void WriteMultiReg_MFC(unsigned short add, unsigned short *values, unsigned short count)
{
    int i, index = 0;

    s_serial.send[index++] = MFC_MID;        // 슬레이브 ID
    s_serial.send[index++] = MBC_WMR;        // MODBUS 명령 0x10 (Write Multiple Registers)
    s_serial.send[index++] = (unsigned char)(add >> 8) & 0xFF;   // 시작 레지스터 주소 상위 바이트
    s_serial.send[index++] = (unsigned char)(add & 0xFF);        // 시작 레지스터 주소 하위 바이트
    s_serial.send[index++] = (unsigned char)(count >> 8) & 0xFF; // 레지스터 개수 상위 바이트
    s_serial.send[index++] = (unsigned char)(count & 0xFF);      // 레지스터 개수 하위 바이트

    s_serial.send[index++] = (unsigned char)(count * 2); // 쓰기 바이트 수 (레지스터 수 x 2)

    // 값 데이터 부분 (count 개수만큼 16비트 값 전송)
    for (i = 0; i > 8) & 0xFF; // 값 상위 바이트
        s_serial.send[index++] = (unsigned char)(values[i] & 0xFF);      // 값 하위 바이트
    }

    s_serial.sendbyte = index;  // 전체 바이트 수 (값 포함)

    AttachModbusCRC(s_serial.sendbyte, s_serial.send);  // CRC16 추가

    SendToCom(&s_serial);  // 송신
    ReadFromCom(&s_serial);  // 응답 수신
}
```

- `values` 매개변수는 메모리상 `unsigned short` 배열(16비트 값들의 리스트)  
- 예를 들어 6개 채널 duty 값 쓰려면 `count=6`이고, `values` 배열은 6개 16비트 정수를 가짐
- 한 레지스터는 2byte(16bit)이므로, 쓰기 데이터 길이는 `count * 2`

- **패킷 구조 (len=13+2*count 바이트, CRC 포함)**  
  | ID(1B) | Func(1B) | Addr Hi(1B) | Addr Lo(1B) | Count Hi(1B) | Count Lo(1B) | Byte Count(1B) | Value1 Hi(1B) | Value1 Lo(1B) | ... | CRC Lo(1B) | CRC Hi(1B) |

***

# 3. CRC16 부착 예

- `AttachModbusCRC()` 함수는 검증을 위해 CRC16 코드를 계산해 마지막에 붙여줍니다.  
- CRC16 알고리즘은 `FunctionSerial.c` 안에 정의되어 있습니다.

***

# 4. 실제 호출 예

- 단일 레지스터 쓰기:  
  `WriteSingleReg_MFC(0x106A, 85); // 펌프 파워 85% 세팅`

- 다중 레지스터 쓰기 (6개 duty 값):  
  ```c
  unsigned short duty_vals[6] = {1000, 2000, 1500, 0, 3000, 2500};
  WriteMultiReg_MFC(0x1086, duty_vals, 6);  // 1번 보드 6개 채널 duty 값 쓰기
  ```

***

아주 쉽게, 실제로 SW(프로그램)에서 MODBUS "발향(emitting)" 명령어를 실행하는 전체 과정을 차근차근 설명해드리겠습니다.
아래에선 3개 포트(11, 21, 23)에 각각 40%, 30%, 30%의 duty를 주는 과정을 예시로 듭니다.

***

## 1. **UI에서 입력**  
- 사용자가 화면에서 11번, 21번, 23번 포트에 각각 "40%", "30%", "30%"라고 입력합니다.

***

## 2. **프로그램 내부 duty 값 준비**  
- 프로그램(예: C 코드)의 duty 배열에 값을 넣습니다.
- 실제로는 100을 곱한 값(소수점X, 정수)으로 저장합니다:
  - 40% → 4000
  - 30% → 3000
- 아래처럼 duty 값 배열을 준비합니다.

```c
unsigned short duty_board1[6] = {0,0,0,0,0,4000}; // 11번 포트(6번째)에 40%
unsigned short duty_board2[6] = {3000,0,3000,0,0,0}; // 21번 포트(1번째), 23번 포트(3번째)에 30%
```

***

## 3. **보정 과정 (SetDutyBoard_MFC 함수 내부)**

- 각 값을 물리적/제품별 보정식에 따라 계산합니다. 예시 공식:
  ```c
  xvalue = (double)duty / 100.0 * fscale / 100.0;
  fduty = 0.0;
  // 여러 보정 파라미터(coeff[], dutyzero[], offset 등) 적용
  for(j=0;j 100.0) fduty = 100.0;
  sduty = (unsigned short)(fduty * 100);
  ```
- 이 과정으로 실제 송신 duty는 **입력값과 다른(대개 보정된) 값**이 됩니다.

***

## 4. **MODBUS 패킷 송신 준비**  
- SetDutyBoard_MFC 함수가 MODBUS 패킷을 아래와 같이 조립합니다:
  - [ID (1)] [0x10 (1)] [시작주소 (2)] [레지스터개수 (2)] [데이터길이 (1)] [각 채널 값 (2*6)] [CRC (2)]
- 각 채널 값을 보정한 duty 값(위의 sduty 변수)로 넣습니다.

***

## 5. **송신 함수 호출**
- 준비된 패킷을 RS232/통신 포트로 전송합니다:
  - SendToCom(&s_serial);

***

## 6. **명령어(emit/run) 실행**
- 송신 끝났으면, MFC(장비)는 해당 duty 값을 받아서 실제 포트(11, 21, 23)에 세팅합니다.
- 필요하면 아래처럼 실행 명령도 추가로 보냅니다.

```c
WriteSingleReg_MFC(MFC_CMD, CMD_RUN);  // Run 명령(발향시작)
```

***

## 7. **정리 – 흐름 요약**

1. **UI에서 % 입력**
2. 내부 배열에 넣음 (100배)
3. 보정식 거침 → 실 값(예: 4450, 3050 등)
4. MODBUS 패킷 조립
5. 전송
6. MFC 장비에 세팅됨
7. Run 명령(emit) 실행

***

## 8. **실제 코드 핵심 예시**

아주 간단히 코어 코드 흐름은 아래와 같습니다.

```c
// 1) duty 값 넣기
duty_board1[5] = 4000; // 11번
duty_board2 = 3000; // 21번
duty_board2[2] = 3000; // 23번

// 2) 송신
SetDutyBoard_MFC(0); // 1번 보드
SetDutyBoard_MFC(1); // 2번 보드
// 3) 발향 시작 명령
WriteSingleReg_MFC(MFC_CMD, CMD_RUN);
```

***

이 순서대로 "emit" (발향) 명령이 동작합니다.  
각 단계에 궁금한 점이 있으면 해당 부분만 더 자세히 알려드릴 수 있습니다!


---


사용자가 예로 든 Python 스타일 `requestScentNo` 함수가  
MODBUS 프로토콜과 MFC 장비의 요구 형식에 맞게 바이트 패킷을 조립하는 예시로 설명드리겠습니다.

***

## 1. 요청 상황 예시

- function code (func) = 16 (WRITE MULTIPLE REGISTERS)
- address = dsComm.ADDRESS_RUN_CLEAR (예: 0x1068 등 MFC_CMD 같은 레지스터)
- qor (quantity of registers) = 8 (쓰기 대상 레지스터 수)
- data_length = 16 (쓰기 데이터 바이트 수, 8레지스터 x 2byte)
- data_command = command (ex: RUN=1, CLEAN=2 등)
- data_scent_no = board number (예: 1,2,3 등)
- duty 값 6개: 예 0, 30, 40, 30, 0, 0 퍼센트

***

## 2. MODBUS 바이트 패킷 구조 예시 (1바이트씩 구간 나누기)

| 구간                  | 설명                         | 값 (예시)                 |
|-----------------------|------------------------------|---------------------------|
| ID                    | 슬레이브 ID                   | 0x01                      |
| Function (func)        | WRITE MULTIPLE REGISTERS (0x10) | 0x10                      |
| Register Address (2B)  | 시작 주소                    | 0x10 0x68 (예: MFC_CMD)   |
| Quantity of Registers (2B) | 쓰기 레지스터 개수            | 0x00 0x08 (8개)           |
| Byte Count (1B)        | 쓰기 데이터 바이트 길이 (16B) | 0x10                      |
| Data Command (2B)      | 명령어                      | 0x00 0x01 (예: RUN=1)     |
| Board No (2B)          | 솔레노이드 보드 번호          | 0x00 0x01                 |
| Duty 1 (2B)            | 첫 번째 채널 duty             | 0x00 0x00 (0%)            |
| Duty 2 (2B)            | 두 번째 채널 duty             | 0x00 0x1E (30)            |
| Duty 3 (2B)            | 세 번째 채널 duty             | 0x00 0x28 (40)            |
| Duty 4 (2B)            | 네 번째 채널 duty             | 0x00 0x1E (30)            |
| Duty 5 (2B)            | 다섯 번째 채널 duty           | 0x00 0x00 (0)             |
| Duty 6 (2B)            | 여섯 번째 채널 duty           | 0x00 0x00 (0)             |
| CRC (2B)               | CRC16 체크섬                 | (자동 계산, 패킷 끝에 부착) |

***

## 3. 바이트 배열 예 (16진수 표기)

```
01 10 10 68 00 08 10
00 01               // command = 1 (RUN)
00 01               // scent_no = 1 (보드번호)
00 00               // duty 1 = 0%
00 1E               // duty 2 = 30%
00 28               // duty 3 = 40%
00 1E               // duty 4 = 30%
00 00               // duty 5 = 0%
00 00               // duty 6 = 0%
CRC_L CRC_H         // CRC16 체크섬 (자동 계산)
```

***

## 4. Python 바이트 조립 간단 예시 코드

```python
def pack_emit_command(id, func, address, qor, data_len, command, board_no, duty_list):
    packet = bytearray()
    packet.append(id)          # 슬레이브 ID
    packet.append(func)        # Function code (0x10)
    packet += address.to_bytes(2, 'big')      # 시작 주소
    packet += qor.to_bytes(2, 'big')          # 레지스터 수
    packet.append(data_len)    # 바이트 수
    
    packet += command.to_bytes(2, 'big')      # 명령어
    packet += board_no.to_bytes(2, 'big')     # 솔레노이드 보드 번호
    
    for duty in duty_list:
        packet += duty.to_bytes(2, 'big')     # 각 채널 duty 값 (0~100)
    
    crc = crc16_modbus(packet)                  # CRC16 계산 (함수 필요)
    packet += crc.to_bytes(2, 'little')        # CRC는 보통 리틀엔디언
    
    return packet

# 호출 예시
id = 1
func = 0x10
address = 0x1068
qor = 8
data_len = 16
command = 1          # RUN 명령
board_no = 1
duty_list = [0, 30, 40, 30, 0, 0]

packet_bytes = pack_emit_command(id, func, address, qor, data_len, command, board_no, duty_list)
print(packet_bytes.hex())
```

***

이런 식으로 **MFC가 요구하는 MODBUS 패킷 구조에 맞춘 바이트 배열**을 만들어 송신하면 됩니다.

추가로 CRC16 계산 함수, 실제 C 코드 연동 방법도 설명 드릴 수 있습니다.


네, 아주 정확하게 이해하셨습니다!  
MODBUS의 "레지스터를 쓴다"는 것과, 예시 함수에서 qor=8의 의미, 그리고 그 아래 8개 파라미터(data_length부터...)가 모두 연관되어 있습니다.

***

## 1. "레지스터를 쓴다"는 뜻

- **레지스터(Register):**  
  - 장비 내부 동작, 설정, 상태를 저장하는 2바이트(16비트) 크기의 메모리 공간(변수)입니다.
  - 각 레지스터는 주소를 통해 구분(예: 0x1068, 0x1069, ...).

- **레지스터를 쓴다(Write Registers):**  
  - "이런 주소(위치)에 이런 값을 써라"라는 명령을 의미합니다.
  - 장비의 동작모드, 실행명령, 파라미터, 펌프 파워 등 다양한 내용을 설정할 때 사용함.
  - MODBUS 프로토콜에선 한 번에 여러 레지스터를 연속해서 쓸 수도 있습니다(WRITE MULTIPLE REGISTERS, func code 16).

***

## 2. requestScentNo 함수에서 qor=8, data_length=16의 의미

- **qor=8**  
  - Quantity Of Registers = 8개 레지스터(2바이트 * 8 = 16바이트)
  - 바로 아래 data_xxxx 값들이 이 8개의 레지스터에 대응합니다.

- **data_length=16**  
  - 실제로 쓸 "바이트" 수 (2바이트 x 8개)
  - MODBUS 프로토콜 규격상 꼭 같이 보내야 하는 값

***

## 3. qor 밑의 8개 데이터 예시

**아래와 같이 8개의 값이 순서대로 MODBUS 패킷에 담기고, 장비 측 8개 연속 레지스터에 저장됩니다.**

| 번호 | 파라미터명              | 설명                       |
|------|------------------------|----------------------------|
| 1    | data_command           | 명령(1:발향, 2:세정 등)    |
| 2    | data_scent_no          | 보드/포트 번호             |
| 3    | data_scent_pump_power  | 발향 펌프 파워             |
| 4    | data_clean_pump_power  | 세정 펌프 파워             |
| 5    | data_scent_period      | 발향 지속 시간             |
| 6    | data_clean_period      | 세정 지속 시간             |
| 7    | data_scent_delay       | 발향 후 지연               |
| 8    | data_cleanup_delay     | 세정 후 지연               |

- 이 각각이 2바이트(16비트) 값이고,  
- 소프트웨어에서는 바이트로 쪼개어 보내면  
- **장비**는 등록된 '주소'(address ~ address+7)에 순서맞춰 하나씩 저장해서 동작함.

***

## 예시 (MODBUS 바이트 구성):

```
[ID][Func][Address Hi][Address Lo][QOR Hi][QOR Lo][ByteCnt]
 [Data_1][Data_2][Data_3]...[Data_8][CRC_L][CRC_H]
```
여기서 Data_1~Data_8이 위 8개 파라미터에 해당!

***

## 결론

- **"레지스터를 쓴다"**란, 정보를 하드웨어의 특정 메모리 공간(레지스터)에 저장하도록 값을 전송하는 것.
- **qor 밑에 나오는 8개 파라미터가, 그 8개의 레지스터에 각각 들어가서 실제 장비 운전 파라미터가 된다**는 의미입니다!

더 궁금하면 실제 예시 데이터 구조, 주소, 값 매핑 등도 구체적으로 정리해 드릴 수 있습니다.

