

---

## 1. SW → 시리얼 전송 (FrSmart / dsComm)

- **FrSmart.py**에서 `requestScentNo()` 같은 함수가 호출됩니다.
    
- 내부에서 **dsComm.py**의 `sendMsgForEmitClean()` 같은 메시지 생성 함수를 부릅니다.
    
- 이 함수가 MODBUS 규격에 맞는 바이트 패킷(슬레이브 ID, 기능 코드, 주소, 데이터, CRC16)을 만들고 `write_data()`로 시리얼 포트에 씁니다.
    
- 이 시점에서 PC OS의 시리얼 드라이버를 거쳐 장치(MCU)로 명령이 전송됩니다.
    

---

## 2. MCU → SW 응답 (ControlPumpMFC / DecodeData_MFC)

- 장치가 MODBUS 응답 패킷을 보내면, PC 쪽 시리얼 수신 버퍼에 들어갑니다.
    
- 수신된 바이트들은 `s_serial.read[]`라는 전역 버퍼에 저장됩니다.
    
- **DecodePacket()**
    
    - 수신된 패킷이 에러(기능코드 + 0x80)인지 확인.
        
    - 정상이라면 `DecodeData_MFC()`로 넘김.
        
- **DecodeData_MFC(add, rdreg)**
    
    1. `s_serial.read`에서 데이터 부분만 잘라 `rdata[]` 배열로 복사.
        
    2. `switch(add)` 문으로 MODBUS의 시작 주소(`add`)를 판단.
        
        - **MFC_NSB**: 솔레노이드 보드 개수를 읽어 `s_mfc.tnsbd`, `tnmfl` 설정, duty/status/dutyzero 메모리 할당.
            
        - **MFC_SPS**: 보드 포트 상태 값을 `s_mfc.status[]`에 저장.
            
        - **MFC_SPA**: 포트 duty 값을 `s_mfc.duty[]`에 저장.
            
        - **MFC_CGP**: 캐리어 가스 압력값 처리.
            
    3. 즉, 여기서 `s_mfc.duty[]`나 `s_mfc.status[]`가 **실시간 응답 값으로 업데이트**됩니다.
        

---

## 3. 핵심 포인트

- **`dutyzero`**: 설정 파일(ConfigProVal.cfg)에서 읽어오는 **무유량(0 flow) 기준 duty 값**입니다. 초기에는 설정 파일 값으로 채워지고, 실시간 응답과는 별개입니다.
    
- **`duty`**: 실제 하드웨어 상태를 반영하는 값. `DecodeData_MFC()`에서 MCU 응답 패킷을 읽어 갱신됩니다.
    
- SW에서 보낸 명령 → MCU 실행 → MCU 응답 → `s_mfc.duty` 업데이트 구조입니다.
    

---

원하시면 제가 **이 송수신 과정을 시퀀스 다이어그램**으로 그려서  
FrSmart → dsComm → 시리얼 드라이버 → MCU → ControlPumpMFC 흐름을 한 눈에 보이게 만들어 드릴까요?  
그렇게 하면 데이터가 어디서 생성되고, 어디서 갱신되는지 더 직관적으로 보실 수 있습니다.

맞아요. 바로 그 `SetDutyBoard_MFC()` 안에서 **퍼센트 → MFC 전송용 듀티(DEC/HEX)** 로 변환돼서 패킷에 실립니다. 흐름과 수식, 그리고 예시값까지 딱 맞춰 정리해드릴게요.

---

## 변환이 일어나는 정확한 위치 (코드 흐름)

* `sbdindex` 보드(6채널 묶음)에 대해:

  1. 시작주소 `add = MFC_SPA + 8*sbdindex` 설정 → `0x1086`(첫 보드 11~~16), `0x108E`(둘째 보드 21~~26)
  2. QOR=6, ByteCount=0x0C 헤더 채우기
  3. 각 채널 `i=0..5`에 대해 **아래 변환** 수행 후, 계산된 **2바이트(상/하위)** 를 `s_serial.send[]`에 써 넣음
  4. `SendToCom()`로 송신

> `sad`가 꺼져 있고(`!sad`) 해당 채널 `s_mfc.duty[...]`가 0이 아니면 **계산 모드**(퍼센트→곡선보정).
> `sad`가 켜져 있거나 해당 채널 값이 0이면 **절대 모드**(값을 있는 그대로 전송).

---

## MCU가 쓰는 정확한 수식 (계산 모드일 때)

아래는 코드 그대로입니다. (괄호 안은 의미)

1. 입력 퍼센트 스케일

```
x = ( s_mfc.duty[dindex+i] / 100.0 ) * fscale / 100.0
```

* 보통 UI가 `%`를 **×100한 정수**로 `s_mfc.duty[]`에 넣습니다.
  예: 30% → 3000 ⇒ x = (3000/100)\*fscale/100 = (30)\*fscale/100 = (p/100)\*fscale

2. 다항식 (계수는 a0..a5 = coeff\[0..5], x^0부터)

```
fduty = Σ_{j=0..5} ( coeff[j] * x^j )
```

3. 채널 오프셋 및 반올림 보정

```
fduty += ( dutyzero[dindex+i] - offset )   // 채널별 zero-flow 정렬
fduty += 0.005                              // 사람이 보는 반올림에 가깝게
```

4. 안정장치(클램프)

```
if (fduty <= dutyzero[dindex+i]) fduty = 0.0;
if (fduty > 100.0)                fduty = 100.0;
```

5. 전송값(정수) & 2바이트 분할

```
DEC = (unsigned short)(fduty * 100);   // 소수점 버림(앞의 +0.005가 반올림 효과)
HEX 상위 = DEC >> 8, 하위 = DEC & 0xFF
```

---

## 예시로 확인 (계수/설정: fscale=2.5, offset=41.0, a0..a5 = 41.2590, 2.4498, 13.7190, -9.1858, 1.3973, 0.6380)

### 채널 11(첫 보드 첫 채널), p=30%

* `zduty(11)=39.0`
* `x = (30/100)*2.5 = 0.75`
* `fduty_poly = a0 + a1 x + a2 x^2 + ... + a5 x^5 ≈ 47.5315`
* `abs_duty = 47.5315 + (39.0 - 41.0) + 0.005 = 45.5365`
* **클램프**: 39.0(zduty)보다 큼, 100 이하 → 통과
* `DEC = ⌊45.5365 * 100⌋ = 4553` → **HEX = 0x11 0xC9**

### 채널 21(둘째 보드 첫 채널), p=30%

* `zduty(21)=38.0`
* 같은 `x = 0.75`, 같은 `fduty_poly ≈ 47.5315`
* `abs_duty = 47.5315 + (38.0 - 41.0) + 0.005 = 44.5365`
* `DEC = 4453` → **HEX = 0x11 0x65**  ← (당신 로그와 일치)

> 그래서 “\*\*1번(=11번)**에 p=30을 넣었을 때는 ‘39 + 약 6.54 ≈ **45.54%**’라서 **4553**이 맞고,
> “**21번**에 p=30”이면 ‘38 + 약 6.54 ≈ **44.54%**’라서 **4453**이 됩니다.
> **같은 퍼센트라도 채널별 zduty가 달라서 최종 DEC가 다르게** 나와요.**

---

## 절대 모드(sad=1)일 때

* 계산을 안 하고 **`s_mfc.duty[]`에 들어있는 값을 그대로 2바이트로 전송**합니다.
  이때는 `x`, 다항식, zduty/offset 보정, 클램프가 적용되지 않습니다.

---

## 요약 한 줄

* 네—**그 자리에서** 퍼센트가 수식대로 변환되어, 우리가 계산한 **DEC/HEX**가 정확히 패킷에 실려 나갑니다.
* 차이는 **채널별 `zduty`(zero‑flow duty)** 때문이라, 같은 퍼센트라도 11번과 21번은 **서로 다른 DEC**가 됩니다.
