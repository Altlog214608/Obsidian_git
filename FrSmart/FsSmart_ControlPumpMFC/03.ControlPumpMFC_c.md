좋아요 👍  
이 `ControlPumpMFC.c` 파일은 앞서 분석했던 **MFC 제어용 헤더 파일(`ControlPumpMFC.h`)**을 실제 동작 코드로 구현한 부분입니다.  
즉, 헤더에서 정의한 매크로/구조체/함수 원형을 사용해서 **UI 초기화, 장치 초기화, MODBUS 통신, 설정값 읽기/쓰기, 펌프·밸브 제어**를 수행하는 **메인 실행 파일**입니다.

아래에서 **흐름별로 분석**드리겠습니다.

---

## 1. 전체 구조 개요

- **환경** : LabWindows/CVI 기반 C 프로그램
    
- **목적** : UI 패널(u_control_mfc_12.uir)과 직렬통신(MODBUS)으로 MFC, 펌프, 솔레노이드 밸브를 제어
    
- **핵심 동작** :
    
    1. 프로그램 시작 → UI 패널 로드
        
    2. 직렬 통신 포트 설정 및 장치 초기화
        
    3. Config 파일 읽어 보정값 로드
        
    4. 타이머로 주기적 데이터 업데이트
        
    5. 버튼 / 슬라이더 조작 시 MODBUS 명령 전송
        

---

## 2. main() 함수
```c
int main (int argc, char *argv[]) {     if (InitCVIRTE (0, argv, 0) == 0)        return -1;     GetProjectDir(proj_dir);     sprintf(fname,"%s\\uir\\source\\%s",proj_dir,"u_control_mfc_12.uir");    control_handle = LoadPanel (0, fname, CPL);    acq_handle = LoadPanel (0, fname, DPNL);     DisplayPanel (control_handle);    SetCtrlAttribute(control_handle,CPL_QUIT,ATTR_VISIBLE,0);     InitProcess();  // 초기화 함수    RunUserInterface ();     return 0; }
```

- **LabWindows/CVI 초기화** (`InitCVIRTE`)
    
- 프로젝트 실행 경로 확보 → `.uir` UI 파일 로드
    
- **두 개의 패널** 로딩 : 제어 패널(`control_handle`)과 데이터 패널(`acq_handle`)
    
- `InitProcess()`로 하드웨어 초기화
    
- `RunUserInterface()`로 UI 이벤트 루프 실행
    

---

## 3. InitProcess() — 장비 초기화 메인 로직
```c
void InitProcess(void) {     ReadConfigCom(&s_serial);   // 직렬통신 포트 설정 읽기    ActivateCom(&s_serial);     // 직렬 포트 열기    Delay(1.5);                 // 장치가 응답할 시간 대기     if (!InitProcess_MFC()) {   // MFC 장치 확인        InitConfig_MFC();       // UI 및 설정 초기화        SetCtrlAttribute(control_handle,CPL_TIMER,ATTR_ENABLED,1); // UI 타이머 동작    } }
```


- 직렬통신 설정 로드 후 포트 열기
    
- `InitProcess_MFC()` : MFC 장치 펌웨어 버전과 보드 개수를 MODBUS로 요청 → 값 없으면 실패
    
- 성공 시 UI 타이머 활성화(주기적 업데이트)
    

---

## 4. InitProcess_MFC() — 장치 상태 체크
```c
int InitProcess_MFC(void) {     int rdreg;    rdreg = 4; ReadRegister_MFC(MBC_RIP, MFC_FVM, rdreg); // 펌웨어 버전 읽기    rdreg = 1; ReadRegister_MFC(MBC_RIP, MFC_NSB, rdreg); // 보드 개수 읽기    DecodeData_MFC(MFC_NSB, rdreg);     if (s_mfc.tnsbd) return 0;  // 보드 개수 유효하면 성공    return -1; }
```

- `ReadRegister_MFC` : MODBUS `0x04(Read Input Register)` 명령으로 특정 주소 읽기
    
- `DecodeData_MFC` : 수신 버퍼를 해석해 `s_mfc` 구조체에 저장
    
- 보드 개수가 0이면 실패 반환
    

---

## 5. InitConfig_MFC() — UI/변수 초기화

- UI 컨트롤 라인 인덱스를 배열(`s_mfc.lhindex[]`)에 설정
    
- 보정값 파일 읽기 (`ReadConfigProVal_MFC`)
    
- 플래그/상태 초기화
    

---

## 6. ReadConfigProVal_MFC() — 보정값 {fscale, offset, coeff[], dutyzero[]} 로드

- 실행 폴더의 `ConfigProVal.cfg` 텍스트 파일을 한 줄씩 읽어 파싱
    
- 내용 예:
    
    text
    
    `fscale = ... offset = ... coeff = ... dutyzero = ...`
    
- 읽은 값들은 `s_mfc` 구조체에 저장 → 나중에 Duty → 실제 밸브 제어값 변환에 사용
    

---

## 7. MODBUS 통신 함수들

## ReadRegister_MFC()
```c
void ReadRegister_MFC(unsigned char readcmd, unsigned short add, unsigned short rdreg) {     s_serial.send[0] = MFC_MID;    s_serial.send[1] = readcmd;    s_serial.send[2] = (add>>8) & 0xFF;    s_serial.send[3] = add & 0xFF;    s_serial.send[4] = (rdreg>>8) & 0xFF;    s_serial.send[5] = rdreg & 0xFF;    s_serial.sendbyte = 6;     SendToCom(&s_serial);    ReadFromCom(&s_serial); }
```


- MODBUS 패킷 생성 후 전송, 즉시 응답 받음
    
- `readcmd` 예: `MBC_RIP(0x04)` 또는 `MBC_RHR(0x03)`
    

## WriteSingleReg_MFC()
```c
void WriteSingleReg_MFC(unsigned short add, unsigned short value) {     s_serial.send[0] = MFC_MID;    s_serial.send[1] = MBC_WSR; // Write Single Register(0x06)    ...    SendToCom(&s_serial);    ReadFromCom(&s_serial); }`
```

- 단일 레지스터에 값 쓰기
    

---

## 8. SetDutyBoard_MFC() — 한 보드(6채널) Duty 값 설정

- 선택한 솔레노이드 보드(`sbdindex`)의 6개 포트 Duty를 순서대로 계산하여 전송
    
- **보정식 적용**:
    
    text
    
    `xvalue = (duty% / 100) * full_scale / 100 fduty = Σ( coeff[j] * xvalue^j ) + (dutyzero - offset)`
    
- 범위 조정 (0~100%)
    
- MODBUS `0x10(Write Multiple Registers)` 사용하여 6개 채널 값을 한 번에 전송
    

---

## 9. ReadDutyBoard_MFC()

- 한 보드 duty 값 읽기, `0x03(Read Holding Registers)`로 8개 word 읽음 (실제 6채널 + 패딩)
    

---

## 10. Error_MFC() — 에러 코드 → 문자열 변환

- MFC에서 반환한 에러 코드 번호를 사람이 읽을 수 있는 텍스트로 변환 후 UI에 표시
    

---

## 11. DecodeData_MFC() — 수신 데이터 해석

- 응답 버퍼에서 데이터 길이와 word 단위 값 추출
    
- 요청한 주소(add)에 따라 `s_mfc` 구조체에 저장하거나 출력
    
- 예: `MFC_NSB` 요청 시 → `s_mfc.tnsbd`에 보드 수 저장
    

---

## 12. QuitProcess()

- 프로그램 종료 시 직렬포트 닫기, 메모리 해제, UI 종료
    

---

## 13. 전체 동작 흐름 요약

1. **프로그램 시작 → UI 로드**
    
2. **InitProcess()**
    
    - 직렬 포트 설정/열기
        
    - MFC 펌웨어 버전, 보드 수 체크
        
    - ConfigProVal.cfg 로드
        
    - UI 라인 매핑
        
3. **사용자 조작**
    
    - 버튼 클릭 시 `WriteSingleReg_MFC` / `SetDutyBoard_MFC` 호출 → 펌프·밸브 제어
        
    - 타이머 이벤트 시 `ReadRegister_MFC`로 상태 주기적 업데이트
        
4. **프로그램 종료**
    
    - QuitProcess()로 통신 종료, 메모리 반환
        

---

📌 **이 C 파일의 본질** :  
이전 `ControlPumpMFC.h`가 **규격서**라면, `ControlPumpMFC.c`는 **실행 파일**입니다.  
MODBUS 명령어를 사용하여 실제 펌프와 솔레노이드 밸브의 동작(전원, 시간, 주파수, duty 등)을 제어하고, 장치 상태를 읽어와 UI에 반영하는 역할을 합니다.  
특히 `SetDutyBoard_MFC()` 안의 **보정 계산 로직**이 핵심적인 장치 제어 알고리즘입니다.

---

원하시면, 제가 **이 `.c` + `.h` 파일 연결 동작 흐름도를 그림으로** 그려서,

- UI 이벤트 → MODBUS 명령 생성 → 직렬 전송 → 장치 응답 → UI 업데이트  
    이 과정을 한눈에 볼 수 있도록 정리해 드릴까요?  
    그러면 전체 로직이 훨씬 직관적으로 이해되실 겁니다.
    

1. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/6cbfc816-4686-48c1-8c59-42ef5e5fed3c/ControlPumpMFC.c](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/6cbfc816-4686-48c1-8c59-42ef5e5fed3c/ControlPumpMFC.c)