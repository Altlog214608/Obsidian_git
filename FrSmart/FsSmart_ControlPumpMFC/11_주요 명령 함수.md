

---

## 실질적인 제어 명령 함수 위치 및 역할

## 1. 주요 제어 명령 함수들 (PC 쪽 코드 내)

- **`WriteSingleReg_MFC(unsigned short add, unsigned short value)`**
    
    - 단일 홀딩 레지스터에 값을 쓰는 MODBUS 요청을 만들어 펌웨어로 전송.
        
    - 예) 특정 펌프 전력, 밸브 상태 등 1개 파라미터 제어.
        
- **`WriteMultiReg_MFC(unsigned short add, unsigned short cmdvalue)`**
    
    - 여러 홀딩 레지스터를 한 번에 쓰는 MODBUS 요청 생성 및 전송.
        
    - 예) 여러 밸브의 duty 값 일괄 제어.
        
- **`SetDutyBoard_MFC(int sbdindex)`**
    
    - 솔레노이드 보드별로 6개 포트에 대해 duty 값을 계산 후, `WriteMultiReg_MFC`를 통해 그룹 단위로 명령 송신.
        
    - 즉, 밸브의 개별 동작 출력을 실제로 제어하는 핵심 함수.
        
- 이들 함수는 **`SendToCom()`** 을 호출하여, MODBUS 명령 패킷을 OS 시리얼 드라이버를 거쳐 펌웨어로 전송함.
    

## 2. 명령 패킷 생성 및 전송 과정

- 함수 안에서 MODBUS 프로토콜에 맞게
    
    - 장치 ID,
        
    - 함수 코드 (예: 0x06 = Write Single Register, 0x10 = Write Multiple Registers),
        
    - 시작 주소,
        
    - 데이터,
        
    - CRC 등을 포함한 패킷을 만든 후,
        
- `SendToCom()` 호출로 시리얼 포트에 데이터를 실제 출력.
    

---

## 펌웨어 쪽 처리 개념

- 펌웨어는 UART 또는 물리적 시리얼 인터페이스를 통해 이 명령 패킷을 수신.
    
- 내부의 MODBUS 프로토콜 스택이 패킷을 해석해,
    
- 명령에 따라 펌프, 밸브 등 실제 하드웨어를 제어.
    

---

## 요약

|함수명|역할|비고|
|---|---|---|
|WriteSingleReg_MFC|홀딩 레지스터 1개 쓰기 명령 생성 및 전송|단일 값 제어용|
|WriteMultiReg_MFC|홀딩 레지스터 여러 개 쓰기 명령 생성 및 전송|다중 값 동시 제어용|
|SetDutyBoard_MFC|특정 솔레노이드 보드 6채널 duty 계산 후 전송|밸브 개별 제어의 핵심 함수|
|SendToCom|MODBUS 패킷 시리얼 포트로 송신|OS 시리얼 드라이버와 하드웨어 사이|

---

즉, **실질적인 제어 명령은 `WriteSingleReg_MFC`, `WriteMultiReg_MFC`, `SetDutyBoard_MFC` 같은 함수에서 내리고, 그 명령 전송을 `SendToCom`이 수행합니다.**

`DecodePacket`이나 `DecodeData_MFC` 함수는 펌웨어에서 받은 **응답 처리/해석**만 담당하며, 제어 명령을 내리지는 않습니다.

---




## 🔍 두 파일의 역할

## 1. 헤더 파일(`ControlPumpMFC.h` 등)

- **명령 코드 상수 정의**  
    예) `CMD_RUN`, `CMD_STOP`, `MFC_CMD` 주소 값
    
- **레지스터 주소 정의**  
    MODBUS에서 어떤 주소에 어떤 기능이 있는지 매핑
    
- **상태 저장 구조체 선언** (`S_MFC`)  
    보드 수, duty, 보정 값 등
    
- **함수 원형 선언**  
    `WriteSingleReg_MFC()`, `SetDutyBoard_MFC()` 같은 제어 함수들 프로토타입
    

즉, **“이런 명령·데이터 형식으로 쓸 거다”라는 규격서 + 인터페이스 정의**입니다.

---

## 2. C 파일(`ControlPumpMFC.c` 등)

- 헤더에 선언된 제어 함수들을 **실제로 구현**
    
    - `WriteSingleReg_MFC()` → MODBUS Single Register Write 명령 패킷 생성·송신
        
    - `SetDutyBoard_MFC()` → 여러 채널 duty 값 계산 후 MODBUS Multi Write 전송
        
    - `ReadRegister_MFC()` → 장치 상태 읽기 명령 전송
        
- 내부적으로 `SendToCom()` → OS 시리얼 드라이버 → UART → 펌웨어
    
- 응답 처리 함수(`DecodePacket()`, `DecodeData_MFC()`)도 구현해서, 장치 응답 해석
    

---

## 🔗 요약 흐름

text

`[헤더 .h]       ← 명령 코드, 레지스터 주소, 구조체, 함수 원형      ↓ [C 구현 .c]     ← MODBUS 제어 명령 패킷 생성 + 시리얼 송신/수신 처리      ↓ 펌웨어(MCU)     ← 명령 해석 → 매니폴드(펌프, 밸브 등) 실제 동작 제어`

- **명령 전송 주역:** C파일의 `WriteSingleReg_MFC`, `WriteMultiReg_MFC`, `SetDutyBoard_MFC`
    
- **데이터/구조 정의:** 헤더파일의 매크로 + 구조체
    

---

✅ 결론  
지금 올리신 **헤더파일 + C파일**이 합쳐져서  
**"PC → 펌웨어로 제어 명령을 보내는 주요 모듈"**이 맞습니다.  
장치는 이 명령을 MODBUS로 받아서 실제 매니폴드/펌프 제어를 하게 됩니다.

---

원하시면, 제가 이 두 파일의 **명령 생성 → SendToCom 송신 → 펌웨어 처리** 과정을 시퀀스 다이어그램으로 그려서 한 번에 보여드릴 수도 있습니다.  
그러면 전체 제어 데이터 흐름이 확실하게 보입니다.  
그렇게 해드릴까요?

1. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/dc3b4d43-737f-481b-92a3-7b3d9ed8480e/ControlPumpMFC.c](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/dc3b4d43-737f-481b-92a3-7b3d9ed8480e/ControlPumpMFC.c)