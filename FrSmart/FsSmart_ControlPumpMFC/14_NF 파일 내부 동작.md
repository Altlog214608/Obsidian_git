`requestScentTest` 함수에 전달되는 파라미터들이 `NF` 관련 파일(예: `ControlPumpNF.c`, `ControlPumpNF.h`)의 동작과 어떻게 연결되어 제어 명령으로 작동하는지 정리해 드리겠습니다.

---

## 1. `requestScentTest` 함수 개요

```python

# requestScentTest (Python)

  

def requestScentTest(self, command):

    scent_no = self.ui_data_protocol_dlg.sb_scentnum.value()

    scent_power = int(self.ui_data_protocol_dlg.textEdit_emit_power.toPlainText())

    clean_power = int(self.ui_data_protocol_dlg.textEdit_clean_power.toPlainText())

    scent_period = int(self.ui_data_protocol_dlg.textEdit_emit_period.toPlainText())

    clean_period = int(self.ui_data_protocol_dlg.textEdit_clean_period.toPlainText())

    scent_delay = int(self.ui_data_protocol_dlg.textEdit_scent_delay.toPlainText())

    cleanup_delay = int(self.ui_data_protocol_dlg.textEdit_cleanup_delay.toPlainText())

    self.requestScentWithValues(

        scent_no,

        command,

        scent_power,

        clean_power,

        scent_period,

        clean_period,

        scent_delay,

        cleanup_delay

    )

```

- 여기서 `command`는 발향(1), 세정(2), 발향&세정(4) 구분값입니다.
    
- `scent_no`는 향 번호 (향료 번호)를 나타내는 것으로 추정됩니다.
    
- 나머지 파라미터는 각각 동작 세기(power), 주기(period), 딜레이(delay) 등 장치 구동 관련 값들입니다.
    

---

## 2. NF 파일 내 관련 함수 및 변수 연결

## 구조체와 주요 변수 (`ControlPumpNF.h`)

```c

/* ControlPumpNF.h */

  

typedef struct {

    int cmdid, scentno, power, level, runtime;

} S_SCENT;

  

S_SCENT s_scent;

```

- `s_scent` 구조체는 명령 ID(`cmdid`), 향 번호(`scentno`), 전력(`power`), 레벨(`level`), 실행 시간(`runtime`) 등을 저장합니다.
    

---

## 제어 명령 작성 및 전송 함수 (`ControlPumpNF.c` 중 일부)

- `WriteMultiRes_NF(unsigned short add, unsigned short qtres)` 함수는 멀티 레지스터 쓰기 명령을 생성해 펌웨어로 보냅니다.
    
- 해당 함수 내에서 `s_scent`의 값들을 다음과 같이 MODBUS 패킷 형태로 바이트 배열에 채웁니다:
    

```c

/* ControlPumpNF.c (발췌) */

  

int WriteMultiRes_NF(unsigned short add, unsigned short qtres) {

    int index = 0;

  

    s_serial.send[index++] = NF_MID;     // 장치 ID

    s_serial.send[index++] = MBC_WMR;    // MODBUS 함수코드: Write Multiple Registers

  

    // 시작 주소 및 레지스터 개수 세팅

    s_serial.send[index++] = (unsigned char)((add >> 8) & 0xFF);

    s_serial.send[index++] = (unsigned char)(add & 0xFF);

    s_serial.send[index++] = (unsigned char)((qtres >> 8) & 0xFF);

    s_serial.send[index++] = (unsigned char)(qtres & 0xFF);

    s_serial.send[index++] = (unsigned char)(qtres * 2);   // 바이트 수

  

    // 명령 ID

    s_serial.send[index++] = 0x00;

    s_serial.send[index++] = (unsigned char)(s_scent.cmdid & 0xFF);

  

    // 향 번호

    s_serial.send[index++] = 0x00;

    s_serial.send[index++] = (unsigned char)(s_scent.scentno & 0xFF);

  

    // 전력, 세기 관련 보정 계산 후 전송 (cpower 계산)

    s_serial.send[index++] = (unsigned char)((cpower >> 8) & 0xFF);

    s_serial.send[index++] = (unsigned char)(cpower & 0xFF);

    s_serial.send[index++] = (unsigned char)((cpower >> 8) & 0xFF);

    s_serial.send[index++] = (unsigned char)(cpower & 0xFF);

  

    // ... (주기, 딜레이 등 나머지 필드 동일 패턴으로 채움)

  

    return SendToCom(&s_serial);

}

```
- 여기서 `cpower`는 UI에서 받은 power 값을 보정 변환한 값이며, 운전 펌프 전력과 세정 펌프 전력에 동일하게 적용하고 있습니다.
    
- 주기(`scent_period`), 딜레이(`scent_delay`) 등도 비슷한 형식으로 패킷에 포함됩니다.
    
- 최종 완성된 명령 패킷은 `SendToCom(&s_serial)` 호출하여 시리얼 포트를 통해 펌웨어로 전송됩니다.
    

---

## 3. 동작 흐름 요약

|UI 함수|내부 전달값 변수|NF 코드 내 매핑 변수|역할 및 기능|
|---|---|---|---|
|`requestScentTest(command)`|`command`|`s_scent.cmdid`|발향(1), 세정(2), 발향&세정(4) 제어 명령 ID 전달|
|UI 창에서 읽은 향 번호|`scent_no`|`s_scent.scentno`|선택된 향(향료) 번호 지정|
|UI 창에서 읽은 전력 값|`scent_power`, `clean_power`|`s_scent.power` / 보정된 `cpower`|운전 및 세정 펌프에 인가할 전력 세기|
|UI 창에서 읽은 기간 및 딜레이|`scent_period`, `clean_period`, `scent_delay`, `cleanup_delay`|시리얼 패킷 내 포함|동작 시간 및 딜레이 제어|
|내부 함수 호출|`WriteMultiRes_NF(...)`|—|완성된 MODBUS 명령 패킷 전송|
|`SendToCom()` 호출|—|—|시리얼 포트 통해 펌웨어로 데이터 송신|

---

## 4. 정리

- UI에서 버튼 클릭 (발향, 세정, 발향&세정)에 따라 `requestScentTest`가 호출되고, 관련 파라미터를 모아 `requestScentWithValues`(내부호출로 추정) 호출.
    
- 이 값들은 `s_scent` 구조체 필드에 저장되어 `WriteMultiRes_NF` 함수가 MODBUS 멀티 레지스터 쓰기 명령을 준비.
    
- `WriteMultiRes_NF`에서 파라미터들을 바이트 배열로 변환해 시리얼 포트 송신(`SendToCom`)으로 펌웨어에 전달.
    
- 펌웨어는 MODBUS 명령을 받아서 해당 펌프/밸브/밸브 관련 하드웨어를 제어합니다.
    

---
