코드 내에서 값이 튀지 않도록 하는 안전장치 역할을 하는 부분이 있는지에 대해 설명드리겠습니다.

주어진 소스코드 및 대화 내용을 종합하면, `ControlPumpMFC.c` 파일 내에 솔레노이드 밸브 및 펌프 제어용 duty 값에 대해 다음과 같은 보정 및 제한 처리가 이루어지고 있습니다.

---

## 값 튀지 않도록 하는 안전장치 관련 코드 위치 및 기능

## 1. `SetDutyBoard_MFC` 함수 내 보정 및 제한 처리 부분

- 이 함수는 각 솔레노이드 보드 6개 밸브의 duty 값을 MODBUS 패킷에 실어 하드웨어에 전송하는 역할을 합니다.
    
- 내부에서 사용자 입력 duty 값(0~100%)에 대해 **5차 다항식 보정 폼**을 적용하여 실제 하드웨어에 맞는 값으로 변환합니다.
    
- 보정 후 아래와 같은 범위 제한 코드가 포함되어 있습니다.
    

c

`if (fduty <= s_mfc.dutyzero[dindex + i])      fduty = 0.0; if (fduty > 100.0)      fduty = 100.0;`

- **설명:**
    
    - `fduty`가 각 채널별 `zduty`(완전 닫힘 기준) 이하이면 0으로 강제 세팅하여 너무 작은 값으로 인한 이상 동작 방지
        
    - `fduty`가 100을 넘으면 100으로 상한 제한하여 허용 범위를 넘어가는 값이 전달되지 않도록 막음
        

---

## 2. `WriteSingleReg_MFC` 등 MODBUS 작성 함수 호출 전후

- `WriteSingleReg_MFC`나 `WriteMultiReg_MFC`, `SetDutyBoard_MFC` 호출 시에는, 내부에서 duty 값들이 위 함수 내 보정 및 제한 후에 데이터화 하여 `s_serial.send` 버퍼에 담기고, CRC 등도 붙여져서 정상 범위 내에서 송신됩니다.
    
- 시리얼 송수신 과정 중 CRC 오류 체크와 패킷 무결성 검사가 코딩되어 있어, **잘못된 패킷/값이 전송되는 경우 통신단에서 오류로 처리됨**.
    

---

## 3. 에러 처리 함수 및 코드

- `Error_MFC(int errindex)` 함수가 있어, 에러 번호에 따라 문자열 메시지를 보여줍니다.
    
- 이 에러 처리에는 레지스터 범위 초과, 데이터값 범위 초과 등의 오류 코드가 정의되어 있어,  
    예를 들어 `VALVE_PWM_RANGE_ERROR`(33), `VALVE_VALUE_RANGE_ERROR`(36) 등으로 값의 범위 관련 오류는 펌웨어 또는 상위 소프트웨어에서 감지 가능함을 알 수 있습니다.
    

---

## 요약

- **SetDutyBoard_MFC 함수** 내에서 값이 최소값보다 작으면 0으로, 최대값(100)을 넘으면 100으로 강제 조정하는 안전장치가 있습니다.
    
- CRC 검사 및 프로토콜 수준에서의 패킷 무결성 검사 기능도 작동하여 잘못된 데이터 통신을 방지합니다.
    
- 에러 코드 분기를 통해 값 범위 초과나 명령 오류 발생시 UI 출력 및 처리 루틴이 있습니다.
    



# MCU 로직: 어디에 무엇이 있나

## 1) 퍼센트 → x 스케일링

- 코드: `SetDutyBoard_MFC()` 내부
    
    ```
    xvalue = (double) s_mfc.duty[dindex + i] / 100.0 * s_mfc.fscale / 100.0;
    ```
    
    UI에서 퍼센트 p(0~100)를 받으면 내부에 **p×100**으로 저장 후 위 연산을 거쳐 **x = (p/100)×fscale**이 됩니다. (예: p=30, fscale=2.5 → x=0.75)
    

## 2) 다항식 보정(계수의 실제 사용 순서)

- 코드:
    
    ```
    fduty = 0.0;
    for (j=0; j<6; j++) fduty += s_mfc.coeff[j] * pow(xvalue, (double)j);
    ```
    
    **coeff[0]가 x⁰(상수항), coeff[1]이 x¹ … coeff[5]가 x⁵** 입니다.  
    즉, Config 파일의 `coeff = 41.2590, 2.4498, 13.7190, -9.1858, 1.3973, 0.6380`는  
    **a0=41.2590, a1=2.4498, a2=13.7190, a3=-9.1858, a4=1.3973, a5=0.6380** 로 사용됩니다. (주석의 a5,a4,… 순서는 파일 설명용이고, 실제 계산은 a0→a5 순)
    

## 3) 채널 기준 오프셋(zduty) 적용 + 반올림 보정

- 코드:
    
    ```
    fduty += (s_mfc.dutyzero[dindex + i] - s_mfc.offset); // zduty - offset
    fduty += 0.005; // 반올림 보정
    ```
    
    Config의 `offset`(기본 41.0)과 각 채널의 `zduty`(예: CH21=38.0)를 이용해 **절대 PWM 기준으로 이동**시킨 뒤, **0.005**를 더해 나중에 정수 변환 시 **반올림과 유사한 효과**를 유도합니다.
    

## 4) 하한/상한 **클램프(안정장치)**

- 코드:
    
    ```
    if (fduty <= s_mfc.dutyzero[dindex + i]) fduty = 0.0;  // 저유량 영역은 0 처리
    if (fduty > 100.0) fduty = 100.0;                      // 0~100% 사이 강제
    ```
    
    **하한:** 절대 duty가 채널의 **zduty 이하이면 0**으로 강제 (실질 무유량 영역 제거)  
    **상한:** 100% 초과 값은 **100%로 강제**  
    → 그래서 문서상 다항식만 보면 100%에서 비현실 값이 나올 수 있어 보여도, **MCU는 절대 0~100% 범위를 벗어나지 않도록 보호**합니다.
    

## 5) 전송값 산출(정수/HEX)

- 코드:
    
    ```
    sduty = (unsigned short) (fduty * 100);
    high = (sduty >> 8) & 0xFF;  low = sduty & 0xFF;
    ```
    
    **DEC = ⌊(abs_duty)×100⌋** (앞서 +0.005 보정으로 “사람 기준 반올림”에 근접)  
    **HEX = 2바이트 분할**(상위/하위)해 MODBUS 다중-레지스터 쓰기 데이터에 채워 전송합니다. 이후 `AttachModbusCRC()`로 CRC를 붙여 송신.
    

---

# 왜 로그와 딱 맞게 떨어졌나 (예: CH21, 30%)

- x = (30/100)×2.5 = **0.75**
    
- fduty_poly = a0 + a1x + … + a5x⁵ = **47.5315**
    
- abs_duty = 47.5315 + (zduty 38.0 − offset 41.0) + 0.005 ≈ **44.5365**
    
- 하한/상한 클램프: 44.5365 > 38.0, < 100 → 그대로 통과
    
- DEC = ⌊44.5365×100⌋ = **4453** → HEX **0x11 0x65**  
    (당신 로그와 일치)
    

---

# 엑셀: MCU 로직 그대로 구현 (ConfigProVal.cfg 자동 반영)

엑셀을 만들어서 올렸습니다. **MCU_Exact_Logic.xlsx**

- **Config** 시트: fscale, offset, **coeff a0~a5**, 채널별 zduty를 ConfigProVal.cfg에서 읽어와 채워둠
    
- **MCU_Mapping** 시트: 0~100%에 대해 각 채널 **DEC/HEX**를 MCU와 **동일한 수식**으로 계산
    
    - `x = (p/100)*fscale`
        
    - `fduty = Σ coeff[j]*x^j` (a0~a5)
        
    - `abs_duty = fduty + (zduty - offset) + 0.005`
        
    - `IF(abs_duty <= zduty, 0, IF(abs_duty > 100, 100, abs_duty))`
        
    - `DEC = INT(abs_duty*100)`, `HEX = DEC2HEX(…,4)`
        
- **Checks** 시트: 공유해 준 앵커(11@40%=4828, 11@50%=5117, 21@30%=4453, 23@20%=4087, 23@30%=4353)를 자동 대조
    

[다운로드: MCU_Exact_Logic.xlsx](sandbox:/mnt/data/MCU_Exact_Logic.xlsx)

---

## 덧: 통신·전송 안정장치(참고)

- **MODBUS CRC 부착**: `AttachModbusCRC()`에서 0xA001 방식으로 CRC 계산·부착 → 수신측 무결성 검증.
    
- **프로토콜 선택/전송**: `SendToCom()`에서 CRC 부착 후 MODBUS 모드로 송신. 디버그 레벨에 따라 hex 로그 출력.
    

---

원하시면:

- 채널별로 **클램프 이전 값**도 표시(디버깅용),
    
- **패킷 생성 시트**(주소 0x1086/0x108E로 묶어서 6채널 WMR 패킷까지 자동 생성)
    
- **fscale/offset 변경 영향 그래프**  
    도 추가해 드릴게요.