코드 내에서 값이 튀지 않도록 하는 안전장치 역할을 하는 부분이 있는지에 대해 설명드리겠습니다.

주어진 소스코드 및 대화 내용을 종합하면, `ControlPumpMFC.c` 파일 내에 솔레노이드 밸브 및 펌프 제어용 duty 값에 대해 다음과 같은 보정 및 제한 처리가 이루어지고 있습니다.

---

## 값 튀지 않도록 하는 안전장치 관련 코드 위치 및 기능

## 1. `SetDutyBoard_MFC` 함수 내 보정 및 제한 처리 부분

- 이 함수는 각 솔레노이드 보드 6개 밸브의 duty 값을 MODBUS 패킷에 실어 하드웨어에 전송하는 역할을 합니다.
    
- 내부에서 사용자 입력 duty 값(0~100%)에 대해 **5차 다항식 보정 폼**을 적용하여 실제 하드웨어에 맞는 값으로 변환합니다.
    
- 보정 후 아래와 같은 범위 제한 코드가 포함되어 있습니다.
    

c

`if (fduty <= s_mfc.dutyzero[dindex + i])      fduty = 0.0; if (fduty > 100.0)      fduty = 100.0;`

- **설명:**
    
    - `fduty`가 각 채널별 `zduty`(완전 닫힘 기준) 이하이면 0으로 강제 세팅하여 너무 작은 값으로 인한 이상 동작 방지
        
    - `fduty`가 100을 넘으면 100으로 상한 제한하여 허용 범위를 넘어가는 값이 전달되지 않도록 막음
        

---

## 2. `WriteSingleReg_MFC` 등 MODBUS 작성 함수 호출 전후

- `WriteSingleReg_MFC`나 `WriteMultiReg_MFC`, `SetDutyBoard_MFC` 호출 시에는, 내부에서 duty 값들이 위 함수 내 보정 및 제한 후에 데이터화 하여 `s_serial.send` 버퍼에 담기고, CRC 등도 붙여져서 정상 범위 내에서 송신됩니다.
    
- 시리얼 송수신 과정 중 CRC 오류 체크와 패킷 무결성 검사가 코딩되어 있어, **잘못된 패킷/값이 전송되는 경우 통신단에서 오류로 처리됨**.
    

---

## 3. 에러 처리 함수 및 코드

- `Error_MFC(int errindex)` 함수가 있어, 에러 번호에 따라 문자열 메시지를 보여줍니다.
    
- 이 에러 처리에는 레지스터 범위 초과, 데이터값 범위 초과 등의 오류 코드가 정의되어 있어,  
    예를 들어 `VALVE_PWM_RANGE_ERROR`(33), `VALVE_VALUE_RANGE_ERROR`(36) 등으로 값의 범위 관련 오류는 펌웨어 또는 상위 소프트웨어에서 감지 가능함을 알 수 있습니다.
    

---

## 요약

- **SetDutyBoard_MFC 함수** 내에서 값이 최소값보다 작으면 0으로, 최대값(100)을 넘으면 100으로 강제 조정하는 안전장치가 있습니다.
    
- CRC 검사 및 프로토콜 수준에서의 패킷 무결성 검사 기능도 작동하여 잘못된 데이터 통신을 방지합니다.
    
- 에러 코드 분기를 통해 값 범위 초과나 명령 오류 발생시 UI 출력 및 처리 루틴이 있습니다.
    



# MCU 로직: 어디에 무엇이 있나

## 1) 퍼센트 → x 스케일링

- 코드: `SetDutyBoard_MFC()` 내부
    
    ```
    xvalue = (double) s_mfc.duty[dindex + i] / 100.0 * s_mfc.fscale / 100.0;
    ```
    
    UI에서 퍼센트 p(0~100)를 받으면 내부에 **p×100**으로 저장 후 위 연산을 거쳐 **x = (p/100)×fscale**이 됩니다. (예: p=30, fscale=2.5 → x=0.75)
    

## 2) 다항식 보정(계수의 실제 사용 순서)

- 코드:
    
    ```
    fduty = 0.0;
    for (j=0; j<6; j++) fduty += s_mfc.coeff[j] * pow(xvalue, (double)j);
    ```
    
    **coeff[0]가 x⁰(상수항), coeff[1]이 x¹ … coeff[5]가 x⁵** 입니다.  
    즉, Config 파일의 `coeff = 41.2590, 2.4498, 13.7190, -9.1858, 1.3973, 0.6380`는  
    **a0=41.2590, a1=2.4498, a2=13.7190, a3=-9.1858, a4=1.3973, a5=0.6380** 로 사용됩니다. (주석의 a5,a4,… 순서는 파일 설명용이고, 실제 계산은 a0→a5 순)
    

## 3) 채널 기준 오프셋(zduty) 적용 + 반올림 보정

- 코드:
    
    ```
    fduty += (s_mfc.dutyzero[dindex + i] - s_mfc.offset); // zduty - offset
    fduty += 0.005; // 반올림 보정
    ```
    
    Config의 `offset`(기본 41.0)과 각 채널의 `zduty`(예: CH21=38.0)를 이용해 **절대 PWM 기준으로 이동**시킨 뒤, **0.005**를 더해 나중에 정수 변환 시 **반올림과 유사한 효과**를 유도합니다.
    

## 4) 하한/상한 **클램프(안정장치)**

- 코드:
    
    ```
    if (fduty <= s_mfc.dutyzero[dindex + i]) fduty = 0.0;  // 저유량 영역은 0 처리
    if (fduty > 100.0) fduty = 100.0;                      // 0~100% 사이 강제
    ```
    
    **하한:** 절대 duty가 채널의 **zduty 이하이면 0**으로 강제 (실질 무유량 영역 제거)  
    **상한:** 100% 초과 값은 **100%로 강제**  
    → 그래서 문서상 다항식만 보면 100%에서 비현실 값이 나올 수 있어 보여도, **MCU는 절대 0~100% 범위를 벗어나지 않도록 보호**합니다.
    

## 5) 전송값 산출(정수/HEX)

- 코드:
    
    ```
    sduty = (unsigned short) (fduty * 100);
    high = (sduty >> 8) & 0xFF;  low = sduty & 0xFF;
    ```
    
    **DEC = ⌊(abs_duty)×100⌋** (앞서 +0.005 보정으로 “사람 기준 반올림”에 근접)  
    **HEX = 2바이트 분할**(상위/하위)해 MODBUS 다중-레지스터 쓰기 데이터에 채워 전송합니다. 이후 `AttachModbusCRC()`로 CRC를 붙여 송신.
    

---

# 왜 로그와 딱 맞게 떨어졌나 (예: CH21, 30%)

- x = (30/100)×2.5 = **0.75**
    
- fduty_poly = a0 + a1x + … + a5x⁵ = **47.5315**
    
- abs_duty = 47.5315 + (zduty 38.0 − offset 41.0) + 0.005 ≈ **44.5365**
    
- 하한/상한 클램프: 44.5365 > 38.0, < 100 → 그대로 통과
    
- DEC = ⌊44.5365×100⌋ = **4453** → HEX **0x11 0x65**  
    (당신 로그와 일치)
    

---

# 엑셀: MCU 로직 그대로 구현 (ConfigProVal.cfg 자동 반영)

엑셀을 만들어서 올렸습니다. **MCU_Exact_Logic.xlsx**

- **Config** 시트: fscale, offset, **coeff a0~a5**, 채널별 zduty를 ConfigProVal.cfg에서 읽어와 채워둠
    
- **MCU_Mapping** 시트: 0~100%에 대해 각 채널 **DEC/HEX**를 MCU와 **동일한 수식**으로 계산
    
    - `x = (p/100)*fscale`
        
    - `fduty = Σ coeff[j]*x^j` (a0~a5)
        
    - `abs_duty = fduty + (zduty - offset) + 0.005`
        
    - `IF(abs_duty <= zduty, 0, IF(abs_duty > 100, 100, abs_duty))`
        
    - `DEC = INT(abs_duty*100)`, `HEX = DEC2HEX(…,4)`
        
- **Checks** 시트: 공유해 준 앵커(11@40%=4828, 11@50%=5117, 21@30%=4453, 23@20%=4087, 23@30%=4353)를 자동 대조
    

[다운로드: MCU_Exact_Logic.xlsx](sandbox:/mnt/data/MCU_Exact_Logic.xlsx)

---

## 덧: 통신·전송 안정장치(참고)

- **MODBUS CRC 부착**: `AttachModbusCRC()`에서 0xA001 방식으로 CRC 계산·부착 → 수신측 무결성 검증.
    
- **프로토콜 선택/전송**: `SendToCom()`에서 CRC 부착 후 MODBUS 모드로 송신. 디버그 레벨에 따라 hex 로그 출력.
    

---

원하시면:

- 채널별로 **클램프 이전 값**도 표시(디버깅용),
    
- **패킷 생성 시트**(주소 0x1086/0x108E로 묶어서 6채널 WMR 패킷까지 자동 생성)
    
- **fscale/offset 변경 영향 그래프**  
    도 추가해 드릴게요.


---

네, 좀 더 자세하게 설명드리겠습니다.

지금까지 대화와 첨부된 소스코드를 기반으로, 시리얼 통신에서 값이 튀지 않도록 하는 안전장치와 데이터 처리 과정을 단계별로 상세히 풀어드릴게요.

---

## 1. 안전장치의 필요성

- 펌웨어와 PC 소프트웨어 간 시리얼 통신에서는 잘못된 값, 이상치가 전송되면 실제 하드웨어에 문제를 일으킬 수 있습니다.
    
- 따라서 값을 보낼 때 범위를 제한하거나 이상 신호를 막는 장치가 반드시 필요합니다.
    

---

## 2. 주요 안전장치 위치

## (1) 값 범위 제한 (ControlPumpMFC.c 내부 `SetDutyBoard_MFC` 함수)

- 내부에서 밸브에 보내는 duty 값 계산 후 다음과 같이 제한합니다.
    

c

`if (fduty <= s_mfc.dutyzero[dindex + i])      fduty = 0.0; if (fduty > 100.0)      fduty = 100.0;`

- 여기서 `fduty`는 다항식 보정, 오프셋, `zduty` 영향 포함한 실제 duty 계산값입니다.
    
- **하한선:** 보드별 밸브가 완전히 닫힌 상태(zduty) 이하이면 0으로 강제 설정
    
- **상한선:** 100%를 초과하면 100으로 제한 (100% 초과는 불가능하므로)
    
- 이 제한으로 입력값이 너무 작거나 과도하게 크면 보드로 이상 신호가 전달되지 않도록 막습니다.
    

---

## (2) CRC 체크 및 패킷 무결성 검사 (FunctionSerial.c)

- 송신 시 `AttachModbusCRC()`로 CRC 값 붙이고,
    
- 수신 시 `CheckModbusCRC()` 함수에서 데이터가 손상됐는지 검사합니다.
    
- CRC 오류 발생 시 즉각 오류 메시지를 띄우고 해당 통신을 무효 처리하므로 오류 수신 데이터가 하드웨어 제어에 반영되지 않습니다.
    

---

## (3) 에러 처리 및 사용자 알림 (ControlPumpMFC.c 내부 `Error_MFC`)

- 에러 발생 시 원인별로 에러 코드가 분류되어 있으며, 메시지가 사용자에게 보여집니다.
    
- 예: `VALVE_PWM_RANGE_ERROR`(33), `VALVE_VALUE_RANGE_ERROR`(36) 등 값 범위 초과에 대한 오류 코드가 있어, 잘못된 값을 보내거나 수신했을 때 처리하도록 되어 있습니다.
    

---

## 3. 데이터 전송 및 처리 흐름 (요약)

1. **사용자 입력값** (0~100%)을
    
2. **fscale, offset, coeff(다항식)**과 `zduty`로 보정하여 실제 장비에 맞는 duty 신호값(`fduty`) 계산
    
3. 계산된 `fduty`가 너무 작으면 0으로, 너무 크면 100으로 제한
    
4. 제한된 값을 100배 곱해 정수화하고 2바이트 MODBUS 패킷에 넣음
    
5. 패킷에 CRC 추가 후 시리얼로 전송
    
6. 수신 시 CRC 체크로 무결성 확보
    
7. 오류 발생 시 `Error_MFC` 함수가 호출되면서 사용자에게 알림
    

---

## 4. 예시 코드 구간 해설 (ControlPumpMFC.c 내 `SetDutyBoard_MFC` 발췌)

c

`// 계산부 xvalue = (double) s_mfc.duty[dindex + i] / 100.0 * s_mfc.fscale / 100.0; fduty = 0.0; for (j=0;j<6;j++) fduty += s_mfc.coeff[j] * pow(xvalue,(double)j); fduty += (s_mfc.dutyzero[dindex + i] - s_mfc.offset); fduty += 0.005; // 반올림 보정 // 안전제한 if (fduty <= s_mfc.dutyzero[dindex + i])      // 최소값 이하면 0으로     fduty = 0.0; if (fduty > 100.0)                             // 최대값 초과 제한     fduty = 100.0; // hw 값 준비 sduty = (unsigned short) (fduty * 100);        // 2바이트로 변환`

---

## 5. CRC 체크 예

- 송신 전 `AttachModbusCRC()` 함수가 패킷 끝에 2바이트 CRC 추가
    
- 수신 후 `CheckModbusCRC()` 함수로 검증
    
- CRC오류 시 프로그램 내부에서 `ErrorCom()` 통해 사용자에게 알림
    
- 통신과 제어를 신뢰할 수 있도록 함
    

---

## 6. 종합

- **값 튀지 않도록 하는 첫 번째 안전장치**는 `SetDutyBoard_MFC` 함수 내에서의 값 범위 제한입니다.
    
- **두 번째 안전장치**는 CRC와 패킷 무결성 검사로 오염된 데이터가 처리되는 것을 방지합니다.
    
- **에러 코드 처리** 시스템은 이상 신호 발생 시 즉각 사용자에게 알림으로 문제를 조기에 인지할 수 있게 합니다.
    

이렇게 다중 레이어로 보완되어 안정적인 밸브 및 펌프 제어가 가능해집니다.

필요하면 이 과정과 함수별 구현 상세, 예외 처리 코드도 단계별로 설명해 드릴 수 있습니다.

1. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/b8cd8a99-7f62-46d2-a561-690075fb2671/MODBUS.h](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/b8cd8a99-7f62-46d2-a561-690075fb2671/MODBUS.h)
2. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/144f28cd-e5dd-4cb4-98ea-1a51748e8715/ConfigCOM.c](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/144f28cd-e5dd-4cb4-98ea-1a51748e8715/ConfigCOM.c)
3. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/458ccd45-7fae-40dd-a31a-1c3a6f8dd7f6/ConfigCOM.h](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/458ccd45-7fae-40dd-a31a-1c3a6f8dd7f6/ConfigCOM.h)
4. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/6936600f-3733-4c17-b2ae-3c5544224f78/ControlPumpMFC.c](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/6936600f-3733-4c17-b2ae-3c5544224f78/ControlPumpMFC.c)
5. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/69a46e12-1f1d-4dfd-8f73-46a40f3f0225/ControlPumpMFC.h](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/69a46e12-1f1d-4dfd-8f73-46a40f3f0225/ControlPumpMFC.h)
6. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/196f44c2-e0d6-4e5a-8ec3-e86e1ffeb0fc/FunctionSerial.c](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/196f44c2-e0d6-4e5a-8ec3-e86e1ffeb0fc/FunctionSerial.c)
7. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/36f44cd5-13fc-4904-8cfa-3834b1a52e01/FunctionSerial.h](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/36f44cd5-13fc-4904-8cfa-3834b1a52e01/FunctionSerial.h)
8. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/cab003b6-2db1-413e-bcf1-2900dc73e862/MODBUS.c](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/cab003b6-2db1-413e-bcf1-2900dc73e862/MODBUS.c)