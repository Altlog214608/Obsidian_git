네, 첨부해주신 **이미지(멀티 플로우 제어 프로그램 UI 캡처)**를 기반으로 실제 제어 기능, UI의 구조, 입력값과 하드웨어 대응 관계를 꼼꼼하게 분석해서 아래에 정리해드릴게요.

---

## 1. UI(프로그램) 구조와 실제 기능 대응

## **상단: 명령/펌프/시간 입력**

- **Command**: RUN/STOP/CLEAN 등 동작 명령 선택.
    
- **Pump power (%)**: 현재 펌프의 출력 세기(%) 설정 입력.
    
- **Run Time (s)**: 펌프 동작 시간(초) 설정.
    

→ **실제 MFC 제어 명령에서 CMD, 펌프 파워, 런타임 값이 레지스터에 기록됨**  
 - 레지스터(MFC_CMD, MFC_RPW, MFC_POT 등)로 변환되어 펌웨어로 전달.

## **버튼 (Run, Stop, View pressure 등)**

- **Run**: 명령 실행 → 시리얼로 MODBUS 요청 패킷 전송.
    
- **Stop**: 펌프/밸브 중지 명령 → 중지명령 패킷 전송.
    
- **View pressure**: 가스 압력 상태 읽기 요청.
    

---

## 2. **밸브 라인 (line_11~16, line_21~26)**

## **배열 구조/의미**

- **line_11~16**: 첫 번째 보드의 6개 벨브(포트) duty(출력값)
    
- **line_21~26**: 두 번째 보드의 6개 벨브(포트) duty(출력값)
    
- 각 라인의 값(0~100.00): 해당 포트의 펌프 또는 밸브 개방률(%)  
     예시: line_11=40.00이면 포트1이 40%로 오픈
    

## **보드별/라인별**

- 보드 #1: line_11~16 (1~6번 포트)
    
- 보드 #2: line_21~26 (7~12번 포트)  
     ※ 실제 펌웨어 주소맵에서도 보드별 6포트 단위로 duty 레지스터를 관리(0x1086~0x108B, 0x108E~0x1093)
    

## **Total (우측 하단)**

- **Total**: 모든 라인 duty 값의 합산.
    
- **100.00(기준)**: 전체 출력값의 합이 100이 되게끔 배분해야함(= 믹싱 비율 총합).
    

## **예시 동작**

- line_11=40.00, line_13=30.00, line_21=30.00 → total=100.00
    
- 즉, 여러 벨브를 동시에 다른 세기로 제어할 때 전체 sum이 100이 되도록 조정
    

---

## 3. **아래 Response/Port 확인**

- **Response**: 펌웨어에서 온 MODBUS 응답 확인 영역(UI에서 값 보여줌)
    
- **value(0x0FBD) = ...**:
    
    - 이건 실제로 연결된 솔레노이드 보드 수나 센서값 등, MODBUS 레지스터 값을 읽은 결과를 의미
        
    - 연결 성공/통신 확인/상태 표시(원격 상태 진단, 디버그용)
        

---

## 4. 실제 제어 알고리즘과 연계

- **사용자가 위 UI에서 명령/세기/시간 입력 → 라인별 duty 배분 → Run 버튼 클릭**
    
    - 각 보드/포트별 duty값이 구조체(duty 배열)에 저장되고,
        
    - `SetDutyBoard_MFC(보드번호)` 함수로 각 보드 duty값이 MODBUS 멀티 레지스터 쓰기 명령으로 팩킹됨
        
    - pump power, run time 등은 개별 레지스터(`MFC_RPW`, `MFC_POT`)에 기록
        
    - Total이 100 미만/초과면 경고 또는 자동 배분(실제 SW 로직에 따라 다름)
        
    - 시리얼 통신으로 펌웨어에 패킷 전송 → 실제 하드웨어 구동
        

---

## **정리 포인트**

- 라인별 입력값: 보드별/포트별 밸브 duty(%)
    
- Total = 전체 믹싱 합산(100이 되게끔 설정 권장)
    
- 명령, 펌프파워, 런타임: 동작 설정값 → 각각 지정 레지스터로 기록
    
- Response: 통신 상태/응답값 표시(진단/에러/상태 체크)
    
- **실제 제어 흐름이 MFC 소스코드의 duty배열 → SetDutyBoard → MODBUS 패킷 → 펌웨어로 연결됨**
    

---

## **실제 현장 목적**

- 다양한 향료/라인(12개)을 원하는 비율(합 100)로 분사
    
- 각 라인은 별도의 밸브(포트)와 직결되고, 명령/파워/시간/비율 전부 소프트웨어에서 실시간 조정 가능
    
- 실질적 하드웨어 제어는 MFC MODBUS 프로토콜 패킷 통해 구동
    

---

필요하면 **이 UI 입력값 ↔ 실제 MODBUS 레지스터 ↔ MFC 소스코드 흐름**을 표나 시퀀스 다이어그램으로 정리해서 보여드릴 수 있습니다.


지금 받은 exe 파일을 실행해서 UI에서 duty(각 밸브/포트의 개방 비율)를 설정하고 ‘Run’을 누르면,  
PC 프로그램이 다음과 같은 순서로 실제 하드웨어로 제어 명령을 보내게 됩니다:

---

## 전체 명령 전송 흐름

1. **PC에서 사용자 입력:**
    
    - exe UI에서 각 라인의 duty 값(예: 1번=40, 3번=30, 11번=30 등)을 입력하고 ‘Run’ 버튼을 클릭합니다.
        
2. **소프트웨어 명령 생성:**
    
    - 소프트웨어가 입력된 duty 값들을 배열(메모리, 예: s_mfc.duty)에 저장하고,
        
    - 해당 duty 값으로 MODBUS Write Multiple Registers 패킷을 만듭니다.
        
    - 펌프 power, run time 등도 별도 MODBUS 명령으로 패킷에 담김.
        
3. **PC OS를 통한 송신:**
    
    - 소프트웨어가 시리얼 통신 함수(SendToCom 등)를 호출하면,
        
    - Windows OS의 시리얼 드라이버(COM포트 드라이버)가 데이터를 실제 하드웨어 포트(UART, USB-시리얼 등)로 전송합니다.
        
4. **보드(펌웨어/MCU)로 명령 전달:**
    
    - 시리얼 케이블을 통해 솔레노이드 밸브/펌프가 달린 MCU(보드)로 명령이 도달.
        
    - 보드의 펌웨어는 MODBUS 패킷을 해석하여 각 밸브와 펌프를 입력 duty 값대로 제어합니다.
        

---

## 요약

**UI에서 duty→ Run → 소프트웨어(MFC 코드) → PC OS 시리얼 드라이버 → UART 물리 송신 → 보드의 펌웨어가 명령 해석 후 동작**

즉,  
“사용자가 PC(프로그램/exe)에서 명령을 내리면  
→ PC의 OS가 시리얼 데이터로 변환해  
→ 하드웨어로 보내고  
→ MCU가 실질적으로 밸브/펌프를 동작시키는 구조”  
입니다.

이 흐름은 지금 제공받은 exe 파일, 헤더/소스코드(MFC 파일들), 그리고 실제 보드와 일치합니다.
