
# 요약

- **수신(Receive)**: RS‑232 콜백 → `ReadFromCom()` 가 원시 바이트를 읽고(CRC 확인) → 최종 해석은 `DecodePacket()`에서 합니다.
    
- **송신(Send / 보드 명령)**: 상위 제어 함수가 MODBUS 프레임을 구성(`WriteSingleRes_NF`, `ReadRegisters_NF`, `WriteMultiRes_NF`) → `SendToCom()`이 CRC/프로토콜 붙여 실제 포트로 써줍니다.
    
- **향 1가지만 분출 로직**: `WriteMultiRes_NF()`가 “병 번호(향 번호) + 펌프 전력 + 동작시간”을 한 번에 보드에 쓰는 다중 레지스터 쓰기(0x10) 패킷을 만들어 보냅니다. 여기서 `s_scent.scentno`가 **선택된 단일 향**, `s_scent.level/runtime`이 강도·지속시간을 결정합니다.
    

---

## 1) 어디서 “바이트 패킷”을 받나?

1. **시리얼 인터럽트 콜백**  
    `InstallComCallback(...)`로 등록된 콜백 `ComCallback()`이 수신 이벤트 때마다 호출되고, 여기서 곧장 `ReadFromCom(&s_serial)`을 부릅니다.
    
2. **실제 읽기 + CRC 검사**  
    `ReadFromCom()`은 포트에서 바이트를 읽고(종단문자 또는 InQ 길이 기반), 디버그면 헥사덤프를 뿌린 다음, 설정된 CRC 종류에 맞춰 **CRC16/MODBUS CRC**를 검사합니다. 이상 없으면 `DecodePacket()`으로 넘깁니다.
    
3. **패킷 해석(응답 처리)**  
    응답 프레임은 `ControlPumpNF.c`의 `DecodePacket()`에서 처리합니다. 에러 응답이면 MODBUS 예외 코드(함수코드 | 0x80)로 분기해 `Error_NF()` 호출, 정상 응답이면 함수코드별로 데이터 바이트 수를 읽어 레지스터 값을 꺼냅니다(예: 입력/홀딩 레지스터 읽기).
    

> 참고: SLIP 프로토콜 경로(`ReadSLIPCom` / `DecodeSLIP`)와 CRC 유틸(`CheckCRC16`, `CheckModbusCRC`)도 같이 포함돼 있지만, 현재 설정에 따라 MODBUS(프로토콜/CRC)가 쓰이도록 짜여 있습니다.

---

## 2) 펌웨어가 보드에 명령을 내리는 지점

### 상위 제어(명령 조립)

- **단일 레지스터 쓰기(예: 펌프 타입 설정 등)**: `WriteSingleRes_NF(add, value)`  
    → [장치 ID(NF_MID), 함수코드(0x06), 주소, 값] 순서로 바이트 배열(`s_serial.send[]`)을 구성 후 `SendToCom()` 호출.
    
- **레지스터 읽기**: `ReadRegisters_NF(readcmd, add, qtres)`  
    → [NF_MID, 함수코드(0x03/0x04), 시작주소, 개수] 프레임 구성 후 전송.
    
- **다중 레지스터 쓰기(핵심: 향 1개 분출)**: `WriteMultiRes_NF(add, qtres)`  
    → 함수코드 **0x10(MBC_WMR)** 사용. 보낼 워드 수×2(바이트 수)와 함께 아래 순서로 페이로드를 채웁니다.
    
    1. **cmdid**: 1=run, 2=clean, 3=stop, 4=run&clean
        
    2. **scentno**: 병(향) 번호 → **단일 향 선택**
        
    3. **pump power**: `s_scent.level`을 30~80%로 매핑(선형 보정)해 `cpower` 계산
        
    4. **clean power**: 동일 `cpower`
        
    5. **run on time(sec)**, **clean on time(sec)**, **post delay** 등  
        마지막에 바이트 수 검증 후 `SendToCom()`으로 송신합니다.
        

> 사용되는 MODBUS 함수코드 매크로는 `MODBUS.h`에 정의되어 있습니다(0x03/0x04/0x06/0x10 등).

### 실제 송신(물리 포트로 내보내는 곳)

- **`SendToCom()`**  
    상위 함수들이 채운 `s_serial.send[]`/`sendbyte`를 받아 **CRC(설정값에 따라 MODBUS CRC 등)를 붙이고**, 프로토콜(terminator/SLIP/MODBUS)에 맞춰 포맷팅한 뒤 **`ComWrt()`로 직렬 포트에 씁니다**. 디버그 레벨에 따라 헥사 로그도 출력합니다.
    

---

## 3) “12개 향 중 하나만” 내보내는 연결 고리

- **병(향) 선택**은 `s_scent.scentno`로 하고, 이것이 `WriteMultiRes_NF()`에서 **NF_BNO(0x1069)** 위치에 들어갑니다. 즉, 한 번의 0x10 다중 레지스터 쓰기에서 “어느 향 병을, 얼마의 세기로, 얼마 동안”을 **단일 병 기준**으로 보드에 전달합니다.
    
- 레지스터 맵은 `ControlPumpNF.h`의 홀딩 레지스터 정의에 정리돼 있고, `NF_CMD`(명령), `NF_BNO`(향 번호), `NF_RPW/CPW`(전력), `NF_POT/COT`(시간) 등으로 구성됩니다.
    

---

## 4) 수명주기 흐름(앱 시작 → 명령 → 응답)

1. `InitProcess()`에서 포트 설정/오픈(`ReadConfigCom`→`ActivateCom`) 후 초기 레지스터 읽기(펌웨어 버전), 펌프 타입 설정 등을 수행. 타이머까지 켜서 주기적으로 압력 읽기.
    
2. 사용자가 UI에서 **Run/Stop**을 누르면 `C_RunProcess()`/`C_StopProcess()`가 `s_scent` 값을 채우고 `WriteMultiRes_NF()` 또는 `NF_CMD`=3(정지) 등을 호출.
    
3. 송신은 `SendToCom()`, 수신은 콜백→`ReadFromCom()`→`DecodePacket()` 경로로 처리.
    

---

## 5) 참고: 시리얼/버퍼 구조체

모든 송수신 버퍼와 포트/프로토콜/CRC 설정은 전역 `s_serial`에 들어 있으며, `read[]/send[]`, 바이트 수(`sendbyte/readbyte`), 프로토콜/CRC 플래그 등이 정의돼 있습니다.

---

필요하시면, 특정 문항/조건에 맞춰 `s_scent`를 어떻게 채워야 “한 번에 한 향”을 정확히 분사할지(타이밍/세기 맵핑, 병 인덱스 범위 체크, 예외 처리)까지 실행 로직 예시를 덧붙여 드릴게요.